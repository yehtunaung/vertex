(function(e, a) { for(var i in a) e[i] = a[i]; }(window, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./libs/datatables-responsive-bs5/responsive.bootstrap5.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./libs/datatables-responsive-bs5/responsive.bootstrap5.js":
/*!*****************************************************************!*\
  !*** ./libs/datatables-responsive-bs5/responsive.bootstrap5.js ***!
  \*****************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var datatables_net_responsive_bs5_js_responsive_bootstrap5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! datatables.net-responsive-bs5/js/responsive.bootstrap5 */ \"./node_modules/datatables.net-responsive-bs5/js/responsive.bootstrap5.js\");\n/* harmony import */ var datatables_net_responsive_bs5_js_responsive_bootstrap5__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(datatables_net_responsive_bs5_js_responsive_bootstrap5__WEBPACK_IMPORTED_MODULE_0__);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWJzL2RhdGF0YWJsZXMtcmVzcG9uc2l2ZS1iczUvcmVzcG9uc2l2ZS5ib290c3RyYXA1LmpzP2RhY2YiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBIiwiZmlsZSI6Ii4vbGlicy9kYXRhdGFibGVzLXJlc3BvbnNpdmUtYnM1L3Jlc3BvbnNpdmUuYm9vdHN0cmFwNS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnZGF0YXRhYmxlcy5uZXQtcmVzcG9uc2l2ZS1iczUvanMvcmVzcG9uc2l2ZS5ib290c3RyYXA1JztcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./libs/datatables-responsive-bs5/responsive.bootstrap5.js\n");

/***/ }),

/***/ "./node_modules/datatables.net-bs5/js/dataTables.bootstrap5.js":
/*!*********************************************************************!*\
  !*** ./node_modules/datatables.net-bs5/js/dataTables.bootstrap5.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! DataTables Bootstrap 5 integration\n * 2020 SpryMedia Ltd - datatables.net/license\n */\n\n/**\n * DataTables integration for Bootstrap 4. This requires Bootstrap 5 and\n * DataTables 1.10 or newer.\n *\n * This file sets the defaults and adds options to DataTables to style its\n * controls using Bootstrap. See http://datatables.net/manual/styling/bootstrap\n * for further information.\n */\n(function( factory ){\n\tif ( true ) {\n\t\t// AMD\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"jquery\"), __webpack_require__(/*! datatables.net */ \"datatables.net\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ( $ ) {\n\t\t\treturn factory( $, window, document );\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\telse {}\n}(function( $, window, document, undefined ) {\n'use strict';\nvar DataTable = $.fn.dataTable;\n\n\n/* Set the defaults for DataTables initialisation */\n$.extend( true, DataTable.defaults, {\n\tdom:\n\t\t\"<'row'<'col-sm-12 col-md-6'l><'col-sm-12 col-md-6'f>>\" +\n\t\t\"<'row'<'col-sm-12'tr>>\" +\n\t\t\"<'row'<'col-sm-12 col-md-5'i><'col-sm-12 col-md-7'p>>\",\n\trenderer: 'bootstrap'\n} );\n\n\n/* Default class modification */\n$.extend( DataTable.ext.classes, {\n\tsWrapper:      \"dataTables_wrapper dt-bootstrap5\",\n\tsFilterInput:  \"form-control form-control-sm\",\n\tsLengthSelect: \"form-select form-select-sm\",\n\tsProcessing:   \"dataTables_processing card\",\n\tsPageButton:   \"paginate_button page-item\"\n} );\n\n\n/* Bootstrap paging button renderer */\nDataTable.ext.renderer.pageButton.bootstrap = function ( settings, host, idx, buttons, page, pages ) {\n\tvar api     = new DataTable.Api( settings );\n\tvar classes = settings.oClasses;\n\tvar lang    = settings.oLanguage.oPaginate;\n\tvar aria = settings.oLanguage.oAria.paginate || {};\n\tvar btnDisplay, btnClass, counter=0;\n\n\tvar attach = function( container, buttons ) {\n\t\tvar i, ien, node, button;\n\t\tvar clickHandler = function ( e ) {\n\t\t\te.preventDefault();\n\t\t\tif ( !$(e.currentTarget).hasClass('disabled') && api.page() != e.data.action ) {\n\t\t\t\tapi.page( e.data.action ).draw( 'page' );\n\t\t\t}\n\t\t};\n\n\t\tfor ( i=0, ien=buttons.length ; i<ien ; i++ ) {\n\t\t\tbutton = buttons[i];\n\n\t\t\tif ( Array.isArray( button ) ) {\n\t\t\t\tattach( container, button );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbtnDisplay = '';\n\t\t\t\tbtnClass = '';\n\n\t\t\t\tswitch ( button ) {\n\t\t\t\t\tcase 'ellipsis':\n\t\t\t\t\t\tbtnDisplay = '&#x2026;';\n\t\t\t\t\t\tbtnClass = 'disabled';\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'first':\n\t\t\t\t\t\tbtnDisplay = lang.sFirst;\n\t\t\t\t\t\tbtnClass = button + (page > 0 ?\n\t\t\t\t\t\t\t'' : ' disabled');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'previous':\n\t\t\t\t\t\tbtnDisplay = lang.sPrevious;\n\t\t\t\t\t\tbtnClass = button + (page > 0 ?\n\t\t\t\t\t\t\t'' : ' disabled');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'next':\n\t\t\t\t\t\tbtnDisplay = lang.sNext;\n\t\t\t\t\t\tbtnClass = button + (page < pages-1 ?\n\t\t\t\t\t\t\t'' : ' disabled');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'last':\n\t\t\t\t\t\tbtnDisplay = lang.sLast;\n\t\t\t\t\t\tbtnClass = button + (page < pages-1 ?\n\t\t\t\t\t\t\t'' : ' disabled');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbtnDisplay = button + 1;\n\t\t\t\t\t\tbtnClass = page === button ?\n\t\t\t\t\t\t\t'active' : '';\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ( btnDisplay ) {\n\t\t\t\t\tnode = $('<li>', {\n\t\t\t\t\t\t\t'class': classes.sPageButton+' '+btnClass,\n\t\t\t\t\t\t\t'id': idx === 0 && typeof button === 'string' ?\n\t\t\t\t\t\t\t\tsettings.sTableId +'_'+ button :\n\t\t\t\t\t\t\t\tnull\n\t\t\t\t\t\t} )\n\t\t\t\t\t\t.append( $('<a>', {\n\t\t\t\t\t\t\t\t'href': '#',\n\t\t\t\t\t\t\t\t'aria-controls': settings.sTableId,\n\t\t\t\t\t\t\t\t'aria-label': aria[ button ],\n\t\t\t\t\t\t\t\t'data-dt-idx': counter,\n\t\t\t\t\t\t\t\t'tabindex': settings.iTabIndex,\n\t\t\t\t\t\t\t\t'class': 'page-link'\n\t\t\t\t\t\t\t} )\n\t\t\t\t\t\t\t.html( btnDisplay )\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.appendTo( container );\n\n\t\t\t\t\tsettings.oApi._fnBindAction(\n\t\t\t\t\t\tnode, {action: button}, clickHandler\n\t\t\t\t\t);\n\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t// IE9 throws an 'unknown error' if document.activeElement is used\n\t// inside an iframe or frame. \n\tvar activeEl;\n\n\ttry {\n\t\t// Because this approach is destroying and recreating the paging\n\t\t// elements, focus is lost on the select button which is bad for\n\t\t// accessibility. So we want to restore focus once the draw has\n\t\t// completed\n\t\tactiveEl = $(host).find(document.activeElement).data('dt-idx');\n\t}\n\tcatch (e) {}\n\n\tattach(\n\t\t$(host).empty().html('<ul class=\"pagination\"/>').children('ul'),\n\t\tbuttons\n\t);\n\n\tif ( activeEl !== undefined ) {\n\t\t$(host).find( '[data-dt-idx='+activeEl+']' ).trigger('focus');\n\t}\n};\n\n\nreturn DataTable;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtYnM1L2pzL2RhdGFUYWJsZXMuYm9vdHN0cmFwNS5qcz82YjhlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQTBDO0FBQ2hEO0FBQ0EsRUFBRSxpQ0FBUSxDQUFDLDJDQUFRLEVBQUUsMkRBQWdCLENBQUMsbUNBQUU7QUFDeEM7QUFDQSxHQUFHO0FBQUEsb0dBQUU7QUFDTDtBQUNBLE1BQU0sRUFvQko7QUFDRixDQUFDO0FBQ0Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLFFBQVE7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kYXRhdGFibGVzLm5ldC1iczUvanMvZGF0YVRhYmxlcy5ib290c3RyYXA1LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohIERhdGFUYWJsZXMgQm9vdHN0cmFwIDUgaW50ZWdyYXRpb25cbiAqIDIwMjAgU3ByeU1lZGlhIEx0ZCAtIGRhdGF0YWJsZXMubmV0L2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIERhdGFUYWJsZXMgaW50ZWdyYXRpb24gZm9yIEJvb3RzdHJhcCA0LiBUaGlzIHJlcXVpcmVzIEJvb3RzdHJhcCA1IGFuZFxuICogRGF0YVRhYmxlcyAxLjEwIG9yIG5ld2VyLlxuICpcbiAqIFRoaXMgZmlsZSBzZXRzIHRoZSBkZWZhdWx0cyBhbmQgYWRkcyBvcHRpb25zIHRvIERhdGFUYWJsZXMgdG8gc3R5bGUgaXRzXG4gKiBjb250cm9scyB1c2luZyBCb290c3RyYXAuIFNlZSBodHRwOi8vZGF0YXRhYmxlcy5uZXQvbWFudWFsL3N0eWxpbmcvYm9vdHN0cmFwXG4gKiBmb3IgZnVydGhlciBpbmZvcm1hdGlvbi5cbiAqL1xuKGZ1bmN0aW9uKCBmYWN0b3J5ICl7XG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZSggWydqcXVlcnknLCAnZGF0YXRhYmxlcy5uZXQnXSwgZnVuY3Rpb24gKCAkICkge1xuXHRcdFx0cmV0dXJuIGZhY3RvcnkoICQsIHdpbmRvdywgZG9jdW1lbnQgKTtcblx0XHR9ICk7XG5cdH1cblx0ZWxzZSBpZiAoIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyApIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvb3QsICQpIHtcblx0XHRcdGlmICggISByb290ICkge1xuXHRcdFx0XHRyb290ID0gd2luZG93O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICEgJCB8fCAhICQuZm4uZGF0YVRhYmxlICkge1xuXHRcdFx0XHQvLyBSZXF1aXJlIERhdGFUYWJsZXMsIHdoaWNoIGF0dGFjaGVzIHRvIGpRdWVyeSwgaW5jbHVkaW5nXG5cdFx0XHRcdC8vIGpRdWVyeSBpZiBuZWVkZWQgYW5kIGhhdmUgYSAkIHByb3BlcnR5IHNvIHdlIGNhbiBhY2Nlc3MgdGhlXG5cdFx0XHRcdC8vIGpRdWVyeSBvYmplY3QgdGhhdCBpcyB1c2VkXG5cdFx0XHRcdCQgPSByZXF1aXJlKCdkYXRhdGFibGVzLm5ldCcpKHJvb3QsICQpLiQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWN0b3J5KCAkLCByb290LCByb290LmRvY3VtZW50ICk7XG5cdFx0fTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBCcm93c2VyXG5cdFx0ZmFjdG9yeSggalF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50ICk7XG5cdH1cbn0oZnVuY3Rpb24oICQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCApIHtcbid1c2Ugc3RyaWN0JztcbnZhciBEYXRhVGFibGUgPSAkLmZuLmRhdGFUYWJsZTtcblxuXG4vKiBTZXQgdGhlIGRlZmF1bHRzIGZvciBEYXRhVGFibGVzIGluaXRpYWxpc2F0aW9uICovXG4kLmV4dGVuZCggdHJ1ZSwgRGF0YVRhYmxlLmRlZmF1bHRzLCB7XG5cdGRvbTpcblx0XHRcIjwncm93JzwnY29sLXNtLTEyIGNvbC1tZC02J2w+PCdjb2wtc20tMTIgY29sLW1kLTYnZj4+XCIgK1xuXHRcdFwiPCdyb3cnPCdjb2wtc20tMTIndHI+PlwiICtcblx0XHRcIjwncm93JzwnY29sLXNtLTEyIGNvbC1tZC01J2k+PCdjb2wtc20tMTIgY29sLW1kLTcncD4+XCIsXG5cdHJlbmRlcmVyOiAnYm9vdHN0cmFwJ1xufSApO1xuXG5cbi8qIERlZmF1bHQgY2xhc3MgbW9kaWZpY2F0aW9uICovXG4kLmV4dGVuZCggRGF0YVRhYmxlLmV4dC5jbGFzc2VzLCB7XG5cdHNXcmFwcGVyOiAgICAgIFwiZGF0YVRhYmxlc193cmFwcGVyIGR0LWJvb3RzdHJhcDVcIixcblx0c0ZpbHRlcklucHV0OiAgXCJmb3JtLWNvbnRyb2wgZm9ybS1jb250cm9sLXNtXCIsXG5cdHNMZW5ndGhTZWxlY3Q6IFwiZm9ybS1zZWxlY3QgZm9ybS1zZWxlY3Qtc21cIixcblx0c1Byb2Nlc3Npbmc6ICAgXCJkYXRhVGFibGVzX3Byb2Nlc3NpbmcgY2FyZFwiLFxuXHRzUGFnZUJ1dHRvbjogICBcInBhZ2luYXRlX2J1dHRvbiBwYWdlLWl0ZW1cIlxufSApO1xuXG5cbi8qIEJvb3RzdHJhcCBwYWdpbmcgYnV0dG9uIHJlbmRlcmVyICovXG5EYXRhVGFibGUuZXh0LnJlbmRlcmVyLnBhZ2VCdXR0b24uYm9vdHN0cmFwID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgaG9zdCwgaWR4LCBidXR0b25zLCBwYWdlLCBwYWdlcyApIHtcblx0dmFyIGFwaSAgICAgPSBuZXcgRGF0YVRhYmxlLkFwaSggc2V0dGluZ3MgKTtcblx0dmFyIGNsYXNzZXMgPSBzZXR0aW5ncy5vQ2xhc3Nlcztcblx0dmFyIGxhbmcgICAgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uub1BhZ2luYXRlO1xuXHR2YXIgYXJpYSA9IHNldHRpbmdzLm9MYW5ndWFnZS5vQXJpYS5wYWdpbmF0ZSB8fCB7fTtcblx0dmFyIGJ0bkRpc3BsYXksIGJ0bkNsYXNzLCBjb3VudGVyPTA7XG5cblx0dmFyIGF0dGFjaCA9IGZ1bmN0aW9uKCBjb250YWluZXIsIGJ1dHRvbnMgKSB7XG5cdFx0dmFyIGksIGllbiwgbm9kZSwgYnV0dG9uO1xuXHRcdHZhciBjbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoIGUgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRpZiAoICEkKGUuY3VycmVudFRhcmdldCkuaGFzQ2xhc3MoJ2Rpc2FibGVkJykgJiYgYXBpLnBhZ2UoKSAhPSBlLmRhdGEuYWN0aW9uICkge1xuXHRcdFx0XHRhcGkucGFnZSggZS5kYXRhLmFjdGlvbiApLmRyYXcoICdwYWdlJyApO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmb3IgKCBpPTAsIGllbj1idXR0b25zLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0YnV0dG9uID0gYnV0dG9uc1tpXTtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBidXR0b24gKSApIHtcblx0XHRcdFx0YXR0YWNoKCBjb250YWluZXIsIGJ1dHRvbiApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGJ0bkRpc3BsYXkgPSAnJztcblx0XHRcdFx0YnRuQ2xhc3MgPSAnJztcblxuXHRcdFx0XHRzd2l0Y2ggKCBidXR0b24gKSB7XG5cdFx0XHRcdFx0Y2FzZSAnZWxsaXBzaXMnOlxuXHRcdFx0XHRcdFx0YnRuRGlzcGxheSA9ICcmI3gyMDI2Oyc7XG5cdFx0XHRcdFx0XHRidG5DbGFzcyA9ICdkaXNhYmxlZCc7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2ZpcnN0Jzpcblx0XHRcdFx0XHRcdGJ0bkRpc3BsYXkgPSBsYW5nLnNGaXJzdDtcblx0XHRcdFx0XHRcdGJ0bkNsYXNzID0gYnV0dG9uICsgKHBhZ2UgPiAwID9cblx0XHRcdFx0XHRcdFx0JycgOiAnIGRpc2FibGVkJyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3ByZXZpb3VzJzpcblx0XHRcdFx0XHRcdGJ0bkRpc3BsYXkgPSBsYW5nLnNQcmV2aW91cztcblx0XHRcdFx0XHRcdGJ0bkNsYXNzID0gYnV0dG9uICsgKHBhZ2UgPiAwID9cblx0XHRcdFx0XHRcdFx0JycgOiAnIGRpc2FibGVkJyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ25leHQnOlxuXHRcdFx0XHRcdFx0YnRuRGlzcGxheSA9IGxhbmcuc05leHQ7XG5cdFx0XHRcdFx0XHRidG5DbGFzcyA9IGJ1dHRvbiArIChwYWdlIDwgcGFnZXMtMSA/XG5cdFx0XHRcdFx0XHRcdCcnIDogJyBkaXNhYmxlZCcpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdsYXN0Jzpcblx0XHRcdFx0XHRcdGJ0bkRpc3BsYXkgPSBsYW5nLnNMYXN0O1xuXHRcdFx0XHRcdFx0YnRuQ2xhc3MgPSBidXR0b24gKyAocGFnZSA8IHBhZ2VzLTEgP1xuXHRcdFx0XHRcdFx0XHQnJyA6ICcgZGlzYWJsZWQnKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGJ0bkRpc3BsYXkgPSBidXR0b24gKyAxO1xuXHRcdFx0XHRcdFx0YnRuQ2xhc3MgPSBwYWdlID09PSBidXR0b24gP1xuXHRcdFx0XHRcdFx0XHQnYWN0aXZlJyA6ICcnO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGJ0bkRpc3BsYXkgKSB7XG5cdFx0XHRcdFx0bm9kZSA9ICQoJzxsaT4nLCB7XG5cdFx0XHRcdFx0XHRcdCdjbGFzcyc6IGNsYXNzZXMuc1BhZ2VCdXR0b24rJyAnK2J0bkNsYXNzLFxuXHRcdFx0XHRcdFx0XHQnaWQnOiBpZHggPT09IDAgJiYgdHlwZW9mIGJ1dHRvbiA9PT0gJ3N0cmluZycgP1xuXHRcdFx0XHRcdFx0XHRcdHNldHRpbmdzLnNUYWJsZUlkICsnXycrIGJ1dHRvbiA6XG5cdFx0XHRcdFx0XHRcdFx0bnVsbFxuXHRcdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0XHQuYXBwZW5kKCAkKCc8YT4nLCB7XG5cdFx0XHRcdFx0XHRcdFx0J2hyZWYnOiAnIycsXG5cdFx0XHRcdFx0XHRcdFx0J2FyaWEtY29udHJvbHMnOiBzZXR0aW5ncy5zVGFibGVJZCxcblx0XHRcdFx0XHRcdFx0XHQnYXJpYS1sYWJlbCc6IGFyaWFbIGJ1dHRvbiBdLFxuXHRcdFx0XHRcdFx0XHRcdCdkYXRhLWR0LWlkeCc6IGNvdW50ZXIsXG5cdFx0XHRcdFx0XHRcdFx0J3RhYmluZGV4Jzogc2V0dGluZ3MuaVRhYkluZGV4LFxuXHRcdFx0XHRcdFx0XHRcdCdjbGFzcyc6ICdwYWdlLWxpbmsnXG5cdFx0XHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdFx0XHQuaHRtbCggYnRuRGlzcGxheSApXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQuYXBwZW5kVG8oIGNvbnRhaW5lciApO1xuXG5cdFx0XHRcdFx0c2V0dGluZ3Mub0FwaS5fZm5CaW5kQWN0aW9uKFxuXHRcdFx0XHRcdFx0bm9kZSwge2FjdGlvbjogYnV0dG9ufSwgY2xpY2tIYW5kbGVyXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdGNvdW50ZXIrKztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvLyBJRTkgdGhyb3dzIGFuICd1bmtub3duIGVycm9yJyBpZiBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGlzIHVzZWRcblx0Ly8gaW5zaWRlIGFuIGlmcmFtZSBvciBmcmFtZS4gXG5cdHZhciBhY3RpdmVFbDtcblxuXHR0cnkge1xuXHRcdC8vIEJlY2F1c2UgdGhpcyBhcHByb2FjaCBpcyBkZXN0cm95aW5nIGFuZCByZWNyZWF0aW5nIHRoZSBwYWdpbmdcblx0XHQvLyBlbGVtZW50cywgZm9jdXMgaXMgbG9zdCBvbiB0aGUgc2VsZWN0IGJ1dHRvbiB3aGljaCBpcyBiYWQgZm9yXG5cdFx0Ly8gYWNjZXNzaWJpbGl0eS4gU28gd2Ugd2FudCB0byByZXN0b3JlIGZvY3VzIG9uY2UgdGhlIGRyYXcgaGFzXG5cdFx0Ly8gY29tcGxldGVkXG5cdFx0YWN0aXZlRWwgPSAkKGhvc3QpLmZpbmQoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkuZGF0YSgnZHQtaWR4Jyk7XG5cdH1cblx0Y2F0Y2ggKGUpIHt9XG5cblx0YXR0YWNoKFxuXHRcdCQoaG9zdCkuZW1wdHkoKS5odG1sKCc8dWwgY2xhc3M9XCJwYWdpbmF0aW9uXCIvPicpLmNoaWxkcmVuKCd1bCcpLFxuXHRcdGJ1dHRvbnNcblx0KTtcblxuXHRpZiAoIGFjdGl2ZUVsICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0JChob3N0KS5maW5kKCAnW2RhdGEtZHQtaWR4PScrYWN0aXZlRWwrJ10nICkudHJpZ2dlcignZm9jdXMnKTtcblx0fVxufTtcblxuXG5yZXR1cm4gRGF0YVRhYmxlO1xufSkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/datatables.net-bs5/js/dataTables.bootstrap5.js\n");

/***/ }),

/***/ "./node_modules/datatables.net-responsive-bs5/js/responsive.bootstrap5.js":
/*!********************************************************************************!*\
  !*** ./node_modules/datatables.net-responsive-bs5/js/responsive.bootstrap5.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Bootstrap 5 integration for DataTables' Responsive\n * Â©2021 SpryMedia Ltd - datatables.net/license\n */\n\n(function( factory ){\n\tif ( true ) {\n\t\t// AMD\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"jquery\"), __webpack_require__(/*! datatables.net-bs5 */ \"./node_modules/datatables.net-bs5/js/dataTables.bootstrap5.js\"), __webpack_require__(/*! datatables.net-responsive */ \"./node_modules/datatables.net-responsive/js/dataTables.responsive.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ( $ ) {\n\t\t\treturn factory( $, window, document );\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\telse {}\n}(function( $, window, document, undefined ) {\n'use strict';\nvar DataTable = $.fn.dataTable;\n\n\nvar _display = DataTable.Responsive.display;\nvar _original = _display.modal;\nvar _modal = $(\n\t'<div class=\"modal fade dtr-bs-modal\" role=\"dialog\">'+\n\t\t'<div class=\"modal-dialog\" role=\"document\">'+\n\t\t\t'<div class=\"modal-content\">'+\n\t\t\t\t'<div class=\"modal-header\">'+\n\t\t\t\t\t'<button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\"></button>'+\n\t\t\t\t'</div>'+\n\t\t\t\t'<div class=\"modal-body\"/>'+\n\t\t\t'</div>'+\n\t\t'</div>'+\n\t'</div>'\n);\nvar modal;\n\n// Need to wait for the document to be ready for Boostrap 5 to be able to initialise to modal\n$(function () {\n\tmodal = new bootstrap.Modal(_modal[0]);\n});\n\n_display.modal = function ( options ) {\n\treturn function ( row, update, render ) {\n\t\tif ( ! $.fn.modal ) {\n\t\t\t_original( row, update, render );\n\t\t}\n\t\telse {\n\t\t\tif ( ! update ) {\n\t\t\t\tif ( options && options.header ) {\n\t\t\t\t\tvar header = _modal.find('div.modal-header');\n\t\t\t\t\tvar button = header.find('button').detach();\n\t\t\t\t\t\n\t\t\t\t\theader\n\t\t\t\t\t\t.empty()\n\t\t\t\t\t\t.append( '<h4 class=\"modal-title\">'+options.header( row )+'</h4>' )\n\t\t\t\t\t\t.append( button );\n\t\t\t\t}\n\n\t\t\t\t_modal.find( 'div.modal-body' )\n\t\t\t\t\t.empty()\n\t\t\t\t\t.append( render() );\n\n\t\t\t\t_modal\n\t\t\t\t\t.appendTo( 'body' )\n\t\t\t\t\t.modal();\n\n\t\t\t\tmodal.show();\n\t\t\t}\n\t\t}\n\t};\n};\n\n\nreturn DataTable.Responsive;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtcmVzcG9uc2l2ZS1iczUvanMvcmVzcG9uc2l2ZS5ib290c3RyYXA1LmpzPzdjYzMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUEwQztBQUNoRDtBQUNBLEVBQUUsaUNBQVEsQ0FBQywyQ0FBUSxFQUFFLDhHQUFvQixFQUFFLDRIQUEyQixDQUFDLG1DQUFFO0FBQ3pFO0FBQ0EsR0FBRztBQUFBLG9HQUFFO0FBQ0w7QUFDQSxNQUFNLEVBcUJKO0FBQ0YsQ0FBQztBQUNEO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtcmVzcG9uc2l2ZS1iczUvanMvcmVzcG9uc2l2ZS5ib290c3RyYXA1LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohIEJvb3RzdHJhcCA1IGludGVncmF0aW9uIGZvciBEYXRhVGFibGVzJyBSZXNwb25zaXZlXG4gKiDCqTIwMjEgU3ByeU1lZGlhIEx0ZCAtIGRhdGF0YWJsZXMubmV0L2xpY2Vuc2VcbiAqL1xuXG4oZnVuY3Rpb24oIGZhY3RvcnkgKXtcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKCBbJ2pxdWVyeScsICdkYXRhdGFibGVzLm5ldC1iczUnLCAnZGF0YXRhYmxlcy5uZXQtcmVzcG9uc2l2ZSddLCBmdW5jdGlvbiAoICQgKSB7XG5cdFx0XHRyZXR1cm4gZmFjdG9yeSggJCwgd2luZG93LCBkb2N1bWVudCApO1xuXHRcdH0gKTtcblx0fVxuXHRlbHNlIGlmICggdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm9vdCwgJCkge1xuXHRcdFx0aWYgKCAhIHJvb3QgKSB7XG5cdFx0XHRcdHJvb3QgPSB3aW5kb3c7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggISAkIHx8ICEgJC5mbi5kYXRhVGFibGUgKSB7XG5cdFx0XHRcdCQgPSByZXF1aXJlKCdkYXRhdGFibGVzLm5ldC1iczUnKShyb290LCAkKS4kO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICEgJC5mbi5kYXRhVGFibGUuUmVzcG9uc2l2ZSApIHtcblx0XHRcdFx0cmVxdWlyZSgnZGF0YXRhYmxlcy5uZXQtcmVzcG9uc2l2ZScpKHJvb3QsICQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFjdG9yeSggJCwgcm9vdCwgcm9vdC5kb2N1bWVudCApO1xuXHRcdH07XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gQnJvd3NlclxuXHRcdGZhY3RvcnkoIGpRdWVyeSwgd2luZG93LCBkb2N1bWVudCApO1xuXHR9XG59KGZ1bmN0aW9uKCAkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQgKSB7XG4ndXNlIHN0cmljdCc7XG52YXIgRGF0YVRhYmxlID0gJC5mbi5kYXRhVGFibGU7XG5cblxudmFyIF9kaXNwbGF5ID0gRGF0YVRhYmxlLlJlc3BvbnNpdmUuZGlzcGxheTtcbnZhciBfb3JpZ2luYWwgPSBfZGlzcGxheS5tb2RhbDtcbnZhciBfbW9kYWwgPSAkKFxuXHQnPGRpdiBjbGFzcz1cIm1vZGFsIGZhZGUgZHRyLWJzLW1vZGFsXCIgcm9sZT1cImRpYWxvZ1wiPicrXG5cdFx0JzxkaXYgY2xhc3M9XCJtb2RhbC1kaWFsb2dcIiByb2xlPVwiZG9jdW1lbnRcIj4nK1xuXHRcdFx0JzxkaXYgY2xhc3M9XCJtb2RhbC1jb250ZW50XCI+Jytcblx0XHRcdFx0JzxkaXYgY2xhc3M9XCJtb2RhbC1oZWFkZXJcIj4nK1xuXHRcdFx0XHRcdCc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0bi1jbG9zZVwiIGRhdGEtYnMtZGlzbWlzcz1cIm1vZGFsXCIgYXJpYS1sYWJlbD1cIkNsb3NlXCI+PC9idXR0b24+Jytcblx0XHRcdFx0JzwvZGl2PicrXG5cdFx0XHRcdCc8ZGl2IGNsYXNzPVwibW9kYWwtYm9keVwiLz4nK1xuXHRcdFx0JzwvZGl2PicrXG5cdFx0JzwvZGl2PicrXG5cdCc8L2Rpdj4nXG4pO1xudmFyIG1vZGFsO1xuXG4vLyBOZWVkIHRvIHdhaXQgZm9yIHRoZSBkb2N1bWVudCB0byBiZSByZWFkeSBmb3IgQm9vc3RyYXAgNSB0byBiZSBhYmxlIHRvIGluaXRpYWxpc2UgdG8gbW9kYWxcbiQoZnVuY3Rpb24gKCkge1xuXHRtb2RhbCA9IG5ldyBib290c3RyYXAuTW9kYWwoX21vZGFsWzBdKTtcbn0pO1xuXG5fZGlzcGxheS5tb2RhbCA9IGZ1bmN0aW9uICggb3B0aW9ucyApIHtcblx0cmV0dXJuIGZ1bmN0aW9uICggcm93LCB1cGRhdGUsIHJlbmRlciApIHtcblx0XHRpZiAoICEgJC5mbi5tb2RhbCApIHtcblx0XHRcdF9vcmlnaW5hbCggcm93LCB1cGRhdGUsIHJlbmRlciApO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICggISB1cGRhdGUgKSB7XG5cdFx0XHRcdGlmICggb3B0aW9ucyAmJiBvcHRpb25zLmhlYWRlciApIHtcblx0XHRcdFx0XHR2YXIgaGVhZGVyID0gX21vZGFsLmZpbmQoJ2Rpdi5tb2RhbC1oZWFkZXInKTtcblx0XHRcdFx0XHR2YXIgYnV0dG9uID0gaGVhZGVyLmZpbmQoJ2J1dHRvbicpLmRldGFjaCgpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGhlYWRlclxuXHRcdFx0XHRcdFx0LmVtcHR5KClcblx0XHRcdFx0XHRcdC5hcHBlbmQoICc8aDQgY2xhc3M9XCJtb2RhbC10aXRsZVwiPicrb3B0aW9ucy5oZWFkZXIoIHJvdyApKyc8L2g0PicgKVxuXHRcdFx0XHRcdFx0LmFwcGVuZCggYnV0dG9uICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfbW9kYWwuZmluZCggJ2Rpdi5tb2RhbC1ib2R5JyApXG5cdFx0XHRcdFx0LmVtcHR5KClcblx0XHRcdFx0XHQuYXBwZW5kKCByZW5kZXIoKSApO1xuXG5cdFx0XHRcdF9tb2RhbFxuXHRcdFx0XHRcdC5hcHBlbmRUbyggJ2JvZHknIClcblx0XHRcdFx0XHQubW9kYWwoKTtcblxuXHRcdFx0XHRtb2RhbC5zaG93KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxuXG5yZXR1cm4gRGF0YVRhYmxlLlJlc3BvbnNpdmU7XG59KSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/datatables.net-responsive-bs5/js/responsive.bootstrap5.js\n");

/***/ }),

/***/ "./node_modules/datatables.net-responsive/js/dataTables.responsive.js":
/*!****************************************************************************!*\
  !*** ./node_modules/datatables.net-responsive/js/dataTables.responsive.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Responsive 2.2.9\n * 2014-2021 SpryMedia Ltd - datatables.net/license\n */\n\n/**\n * @summary     Responsive\n * @description Responsive tables plug-in for DataTables\n * @version     2.2.9\n * @file        dataTables.responsive.js\n * @author      SpryMedia Ltd (www.sprymedia.co.uk)\n * @contact     www.sprymedia.co.uk/contact\n * @copyright   Copyright 2014-2021 SpryMedia Ltd.\n *\n * This source file is free software, available under the following license:\n *   MIT license - http://datatables.net/license/mit\n *\n * This source file is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\n *\n * For details please refer to: http://www.datatables.net\n */\n(function( factory ){\n\tif ( true ) {\n\t\t// AMD\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"jquery\"), __webpack_require__(/*! datatables.net */ \"datatables.net\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ( $ ) {\n\t\t\treturn factory( $, window, document );\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\telse {}\n}(function( $, window, document, undefined ) {\n'use strict';\nvar DataTable = $.fn.dataTable;\n\n\n/**\n * Responsive is a plug-in for the DataTables library that makes use of\n * DataTables' ability to change the visibility of columns, changing the\n * visibility of columns so the displayed columns fit into the table container.\n * The end result is that complex tables will be dynamically adjusted to fit\n * into the viewport, be it on a desktop, tablet or mobile browser.\n *\n * Responsive for DataTables has two modes of operation, which can used\n * individually or combined:\n *\n * * Class name based control - columns assigned class names that match the\n *   breakpoint logic can be shown / hidden as required for each breakpoint.\n * * Automatic control - columns are automatically hidden when there is no\n *   room left to display them. Columns removed from the right.\n *\n * In additional to column visibility control, Responsive also has built into\n * options to use DataTables' child row display to show / hide the information\n * from the table that has been hidden. There are also two modes of operation\n * for this child row display:\n *\n * * Inline - when the control element that the user can use to show / hide\n *   child rows is displayed inside the first column of the table.\n * * Column - where a whole column is dedicated to be the show / hide control.\n *\n * Initialisation of Responsive is performed by:\n *\n * * Adding the class `responsive` or `dt-responsive` to the table. In this case\n *   Responsive will automatically be initialised with the default configuration\n *   options when the DataTable is created.\n * * Using the `responsive` option in the DataTables configuration options. This\n *   can also be used to specify the configuration options, or simply set to\n *   `true` to use the defaults.\n *\n *  @class\n *  @param {object} settings DataTables settings object for the host table\n *  @param {object} [opts] Configuration options\n *  @requires jQuery 1.7+\n *  @requires DataTables 1.10.3+\n *\n *  @example\n *      $('#example').DataTable( {\n *        responsive: true\n *      } );\n *    } );\n */\nvar Responsive = function ( settings, opts ) {\n\t// Sanity check that we are using DataTables 1.10 or newer\n\tif ( ! DataTable.versionCheck || ! DataTable.versionCheck( '1.10.10' ) ) {\n\t\tthrow 'DataTables Responsive requires DataTables 1.10.10 or newer';\n\t}\n\n\tthis.s = {\n\t\tdt: new DataTable.Api( settings ),\n\t\tcolumns: [],\n\t\tcurrent: []\n\t};\n\n\t// Check if responsive has already been initialised on this table\n\tif ( this.s.dt.settings()[0].responsive ) {\n\t\treturn;\n\t}\n\n\t// details is an object, but for simplicity the user can give it as a string\n\t// or a boolean\n\tif ( opts && typeof opts.details === 'string' ) {\n\t\topts.details = { type: opts.details };\n\t}\n\telse if ( opts && opts.details === false ) {\n\t\topts.details = { type: false };\n\t}\n\telse if ( opts && opts.details === true ) {\n\t\topts.details = { type: 'inline' };\n\t}\n\n\tthis.c = $.extend( true, {}, Responsive.defaults, DataTable.defaults.responsive, opts );\n\tsettings.responsive = this;\n\tthis._constructor();\n};\n\n$.extend( Responsive.prototype, {\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Constructor\n\t */\n\n\t/**\n\t * Initialise the Responsive instance\n\t *\n\t * @private\n\t */\n\t_constructor: function ()\n\t{\n\t\tvar that = this;\n\t\tvar dt = this.s.dt;\n\t\tvar dtPrivateSettings = dt.settings()[0];\n\t\tvar oldWindowWidth = $(window).innerWidth();\n\n\t\tdt.settings()[0]._responsive = this;\n\n\t\t// Use DataTables' throttle function to avoid processor thrashing on\n\t\t// resize\n\t\t$(window).on( 'resize.dtr orientationchange.dtr', DataTable.util.throttle( function () {\n\t\t\t// iOS has a bug whereby resize can fire when only scrolling\n\t\t\t// See: http://stackoverflow.com/questions/8898412\n\t\t\tvar width = $(window).innerWidth();\n\n\t\t\tif ( width !== oldWindowWidth ) {\n\t\t\t\tthat._resize();\n\t\t\t\toldWindowWidth = width;\n\t\t\t}\n\t\t} ) );\n\n\t\t// DataTables doesn't currently trigger an event when a row is added, so\n\t\t// we need to hook into its private API to enforce the hidden rows when\n\t\t// new data is added\n\t\tdtPrivateSettings.oApi._fnCallbackReg( dtPrivateSettings, 'aoRowCreatedCallback', function (tr, data, idx) {\n\t\t\tif ( $.inArray( false, that.s.current ) !== -1 ) {\n\t\t\t\t$('>td, >th', tr).each( function ( i ) {\n\t\t\t\t\tvar idx = dt.column.index( 'toData', i );\n\n\t\t\t\t\tif ( that.s.current[idx] === false ) {\n\t\t\t\t\t\t$(this).css('display', 'none');\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\n\t\t// Destroy event handler\n\t\tdt.on( 'destroy.dtr', function () {\n\t\t\tdt.off( '.dtr' );\n\t\t\t$( dt.table().body() ).off( '.dtr' );\n\t\t\t$(window).off( 'resize.dtr orientationchange.dtr' );\n\t\t\tdt.cells('.dtr-control').nodes().to$().removeClass('dtr-control');\n\n\t\t\t// Restore the columns that we've hidden\n\t\t\t$.each( that.s.current, function ( i, val ) {\n\t\t\t\tif ( val === false ) {\n\t\t\t\t\tthat._setColumnVis( i, true );\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\n\t\t// Reorder the breakpoints array here in case they have been added out\n\t\t// of order\n\t\tthis.c.breakpoints.sort( function (a, b) {\n\t\t\treturn a.width < b.width ? 1 :\n\t\t\t\ta.width > b.width ? -1 : 0;\n\t\t} );\n\n\t\tthis._classLogic();\n\t\tthis._resizeAuto();\n\n\t\t// Details handler\n\t\tvar details = this.c.details;\n\n\t\tif ( details.type !== false ) {\n\t\t\tthat._detailsInit();\n\n\t\t\t// DataTables will trigger this event on every column it shows and\n\t\t\t// hides individually\n\t\t\tdt.on( 'column-visibility.dtr', function () {\n\t\t\t\t// Use a small debounce to allow multiple columns to be set together\n\t\t\t\tif ( that._timer ) {\n\t\t\t\t\tclearTimeout( that._timer );\n\t\t\t\t}\n\n\t\t\t\tthat._timer = setTimeout( function () {\n\t\t\t\t\tthat._timer = null;\n\n\t\t\t\t\tthat._classLogic();\n\t\t\t\t\tthat._resizeAuto();\n\t\t\t\t\tthat._resize(true);\n\n\t\t\t\t\tthat._redrawChildren();\n\t\t\t\t}, 100 );\n\t\t\t} );\n\n\t\t\t// Redraw the details box on each draw which will happen if the data\n\t\t\t// has changed. This is used until DataTables implements a native\n\t\t\t// `updated` event for rows\n\t\t\tdt.on( 'draw.dtr', function () {\n\t\t\t\tthat._redrawChildren();\n\t\t\t} );\n\n\t\t\t$(dt.table().node()).addClass( 'dtr-'+details.type );\n\t\t}\n\n\t\tdt.on( 'column-reorder.dtr', function (e, settings, details) {\n\t\t\tthat._classLogic();\n\t\t\tthat._resizeAuto();\n\t\t\tthat._resize(true);\n\t\t} );\n\n\t\t// Change in column sizes means we need to calc\n\t\tdt.on( 'column-sizing.dtr', function () {\n\t\t\tthat._resizeAuto();\n\t\t\tthat._resize();\n\t\t});\n\n\t\t// On Ajax reload we want to reopen any child rows which are displayed\n\t\t// by responsive\n\t\tdt.on( 'preXhr.dtr', function () {\n\t\t\tvar rowIds = [];\n\t\t\tdt.rows().every( function () {\n\t\t\t\tif ( this.child.isShown() ) {\n\t\t\t\t\trowIds.push( this.id(true) );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tdt.one( 'draw.dtr', function () {\n\t\t\t\tthat._resizeAuto();\n\t\t\t\tthat._resize();\n\n\t\t\t\tdt.rows( rowIds ).every( function () {\n\t\t\t\t\tthat._detailsDisplay( this, false );\n\t\t\t\t} );\n\t\t\t} );\n\t\t});\n\n\t\tdt\n\t\t\t.on( 'draw.dtr', function () {\n\t\t\t\tthat._controlClass();\n\t\t\t})\n\t\t\t.on( 'init.dtr', function (e, settings, details) {\n\t\t\t\tif ( e.namespace !== 'dt' ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthat._resizeAuto();\n\t\t\t\tthat._resize();\n\n\t\t\t\t// If columns were hidden, then DataTables needs to adjust the\n\t\t\t\t// column sizing\n\t\t\t\tif ( $.inArray( false, that.s.current ) ) {\n\t\t\t\t\tdt.columns.adjust();\n\t\t\t\t}\n\t\t\t} );\n\n\t\t// First pass - draw the table for the current viewport size\n\t\tthis._resize();\n\t},\n\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Private methods\n\t */\n\n\t/**\n\t * Calculate the visibility for the columns in a table for a given\n\t * breakpoint. The result is pre-determined based on the class logic if\n\t * class names are used to control all columns, but the width of the table\n\t * is also used if there are columns which are to be automatically shown\n\t * and hidden.\n\t *\n\t * @param  {string} breakpoint Breakpoint name to use for the calculation\n\t * @return {array} Array of boolean values initiating the visibility of each\n\t *   column.\n\t *  @private\n\t */\n\t_columnsVisiblity: function ( breakpoint )\n\t{\n\t\tvar dt = this.s.dt;\n\t\tvar columns = this.s.columns;\n\t\tvar i, ien;\n\n\t\t// Create an array that defines the column ordering based first on the\n\t\t// column's priority, and secondly the column index. This allows the\n\t\t// columns to be removed from the right if the priority matches\n\t\tvar order = columns\n\t\t\t.map( function ( col, idx ) {\n\t\t\t\treturn {\n\t\t\t\t\tcolumnIdx: idx,\n\t\t\t\t\tpriority: col.priority\n\t\t\t\t};\n\t\t\t} )\n\t\t\t.sort( function ( a, b ) {\n\t\t\t\tif ( a.priority !== b.priority ) {\n\t\t\t\t\treturn a.priority - b.priority;\n\t\t\t\t}\n\t\t\t\treturn a.columnIdx - b.columnIdx;\n\t\t\t} );\n\n\t\t// Class logic - determine which columns are in this breakpoint based\n\t\t// on the classes. If no class control (i.e. `auto`) then `-` is used\n\t\t// to indicate this to the rest of the function\n\t\tvar display = $.map( columns, function ( col, i ) {\n\t\t\tif ( dt.column(i).visible() === false ) {\n\t\t\t\treturn 'not-visible';\n\t\t\t}\n\t\t\treturn col.auto && col.minWidth === null ?\n\t\t\t\tfalse :\n\t\t\t\tcol.auto === true ?\n\t\t\t\t\t'-' :\n\t\t\t\t\t$.inArray( breakpoint, col.includeIn ) !== -1;\n\t\t} );\n\n\t\t// Auto column control - first pass: how much width is taken by the\n\t\t// ones that must be included from the non-auto columns\n\t\tvar requiredWidth = 0;\n\t\tfor ( i=0, ien=display.length ; i<ien ; i++ ) {\n\t\t\tif ( display[i] === true ) {\n\t\t\t\trequiredWidth += columns[i].minWidth;\n\t\t\t}\n\t\t}\n\n\t\t// Second pass, use up any remaining width for other columns. For\n\t\t// scrolling tables we need to subtract the width of the scrollbar. It\n\t\t// may not be requires which makes this sub-optimal, but it would\n\t\t// require another full redraw to make complete use of those extra few\n\t\t// pixels\n\t\tvar scrolling = dt.settings()[0].oScroll;\n\t\tvar bar = scrolling.sY || scrolling.sX ? scrolling.iBarWidth : 0;\n\t\tvar widthAvailable = dt.table().container().offsetWidth - bar;\n\t\tvar usedWidth = widthAvailable - requiredWidth;\n\n\t\t// Control column needs to always be included. This makes it sub-\n\t\t// optimal in terms of using the available with, but to stop layout\n\t\t// thrashing or overflow. Also we need to account for the control column\n\t\t// width first so we know how much width is available for the other\n\t\t// columns, since the control column might not be the first one shown\n\t\tfor ( i=0, ien=display.length ; i<ien ; i++ ) {\n\t\t\tif ( columns[i].control ) {\n\t\t\t\tusedWidth -= columns[i].minWidth;\n\t\t\t}\n\t\t}\n\n\t\t// Allow columns to be shown (counting by priority and then right to\n\t\t// left) until we run out of room\n\t\tvar empty = false;\n\t\tfor ( i=0, ien=order.length ; i<ien ; i++ ) {\n\t\t\tvar colIdx = order[i].columnIdx;\n\n\t\t\tif ( display[colIdx] === '-' && ! columns[colIdx].control && columns[colIdx].minWidth ) {\n\t\t\t\t// Once we've found a column that won't fit we don't let any\n\t\t\t\t// others display either, or columns might disappear in the\n\t\t\t\t// middle of the table\n\t\t\t\tif ( empty || usedWidth - columns[colIdx].minWidth < 0 ) {\n\t\t\t\t\tempty = true;\n\t\t\t\t\tdisplay[colIdx] = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdisplay[colIdx] = true;\n\t\t\t\t}\n\n\t\t\t\tusedWidth -= columns[colIdx].minWidth;\n\t\t\t}\n\t\t}\n\n\t\t// Determine if the 'control' column should be shown (if there is one).\n\t\t// This is the case when there is a hidden column (that is not the\n\t\t// control column). The two loops look inefficient here, but they are\n\t\t// trivial and will fly through. We need to know the outcome from the\n\t\t// first , before the action in the second can be taken\n\t\tvar showControl = false;\n\n\t\tfor ( i=0, ien=columns.length ; i<ien ; i++ ) {\n\t\t\tif ( ! columns[i].control && ! columns[i].never && display[i] === false ) {\n\t\t\t\tshowControl = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor ( i=0, ien=columns.length ; i<ien ; i++ ) {\n\t\t\tif ( columns[i].control ) {\n\t\t\t\tdisplay[i] = showControl;\n\t\t\t}\n\n\t\t\t// Replace not visible string with false from the control column detection above\n\t\t\tif ( display[i] === 'not-visible' ) {\n\t\t\t\tdisplay[i] = false;\n\t\t\t}\n\t\t}\n\n\t\t// Finally we need to make sure that there is at least one column that\n\t\t// is visible\n\t\tif ( $.inArray( true, display ) === -1 ) {\n\t\t\tdisplay[0] = true;\n\t\t}\n\n\t\treturn display;\n\t},\n\n\n\t/**\n\t * Create the internal `columns` array with information about the columns\n\t * for the table. This includes determining which breakpoints the column\n\t * will appear in, based upon class names in the column, which makes up the\n\t * vast majority of this method.\n\t *\n\t * @private\n\t */\n\t_classLogic: function ()\n\t{\n\t\tvar that = this;\n\t\tvar calc = {};\n\t\tvar breakpoints = this.c.breakpoints;\n\t\tvar dt = this.s.dt;\n\t\tvar columns = dt.columns().eq(0).map( function (i) {\n\t\t\tvar column = this.column(i);\n\t\t\tvar className = column.header().className;\n\t\t\tvar priority = dt.settings()[0].aoColumns[i].responsivePriority;\n\t\t\tvar dataPriority = column.header().getAttribute('data-priority');\n\n\t\t\tif ( priority === undefined ) {\n\t\t\t\tpriority = dataPriority === undefined || dataPriority === null?\n\t\t\t\t\t10000 :\n\t\t\t\t\tdataPriority * 1;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tclassName: className,\n\t\t\t\tincludeIn: [],\n\t\t\t\tauto:      false,\n\t\t\t\tcontrol:   false,\n\t\t\t\tnever:     className.match(/\\bnever\\b/) ? true : false,\n\t\t\t\tpriority:  priority\n\t\t\t};\n\t\t} );\n\n\t\t// Simply add a breakpoint to `includeIn` array, ensuring that there are\n\t\t// no duplicates\n\t\tvar add = function ( colIdx, name ) {\n\t\t\tvar includeIn = columns[ colIdx ].includeIn;\n\n\t\t\tif ( $.inArray( name, includeIn ) === -1 ) {\n\t\t\t\tincludeIn.push( name );\n\t\t\t}\n\t\t};\n\n\t\tvar column = function ( colIdx, name, operator, matched ) {\n\t\t\tvar size, i, ien;\n\n\t\t\tif ( ! operator ) {\n\t\t\t\tcolumns[ colIdx ].includeIn.push( name );\n\t\t\t}\n\t\t\telse if ( operator === 'max-' ) {\n\t\t\t\t// Add this breakpoint and all smaller\n\t\t\t\tsize = that._find( name ).width;\n\n\t\t\t\tfor ( i=0, ien=breakpoints.length ; i<ien ; i++ ) {\n\t\t\t\t\tif ( breakpoints[i].width <= size ) {\n\t\t\t\t\t\tadd( colIdx, breakpoints[i].name );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( operator === 'min-' ) {\n\t\t\t\t// Add this breakpoint and all larger\n\t\t\t\tsize = that._find( name ).width;\n\n\t\t\t\tfor ( i=0, ien=breakpoints.length ; i<ien ; i++ ) {\n\t\t\t\t\tif ( breakpoints[i].width >= size ) {\n\t\t\t\t\t\tadd( colIdx, breakpoints[i].name );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( operator === 'not-' ) {\n\t\t\t\t// Add all but this breakpoint\n\t\t\t\tfor ( i=0, ien=breakpoints.length ; i<ien ; i++ ) {\n\t\t\t\t\tif ( breakpoints[i].name.indexOf( matched ) === -1 ) {\n\t\t\t\t\t\tadd( colIdx, breakpoints[i].name );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Loop over each column and determine if it has a responsive control\n\t\t// class\n\t\tcolumns.each( function ( col, i ) {\n\t\t\tvar classNames = col.className.split(' ');\n\t\t\tvar hasClass = false;\n\n\t\t\t// Split the class name up so multiple rules can be applied if needed\n\t\t\tfor ( var k=0, ken=classNames.length ; k<ken ; k++ ) {\n\t\t\t\tvar className = classNames[k].trim();\n\n\t\t\t\tif ( className === 'all' ) {\n\t\t\t\t\t// Include in all\n\t\t\t\t\thasClass = true;\n\t\t\t\t\tcol.includeIn = $.map( breakpoints, function (a) {\n\t\t\t\t\t\treturn a.name;\n\t\t\t\t\t} );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse if ( className === 'none' || col.never ) {\n\t\t\t\t\t// Include in none (default) and no auto\n\t\t\t\t\thasClass = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse if ( className === 'control' || className === 'dtr-control' ) {\n\t\t\t\t\t// Special column that is only visible, when one of the other\n\t\t\t\t\t// columns is hidden. This is used for the details control\n\t\t\t\t\thasClass = true;\n\t\t\t\t\tcol.control = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t$.each( breakpoints, function ( j, breakpoint ) {\n\t\t\t\t\t// Does this column have a class that matches this breakpoint?\n\t\t\t\t\tvar brokenPoint = breakpoint.name.split('-');\n\t\t\t\t\tvar re = new RegExp( '(min\\\\-|max\\\\-|not\\\\-)?('+brokenPoint[0]+')(\\\\-[_a-zA-Z0-9])?' );\n\t\t\t\t\tvar match = className.match( re );\n\n\t\t\t\t\tif ( match ) {\n\t\t\t\t\t\thasClass = true;\n\n\t\t\t\t\t\tif ( match[2] === brokenPoint[0] && match[3] === '-'+brokenPoint[1] ) {\n\t\t\t\t\t\t\t// Class name matches breakpoint name fully\n\t\t\t\t\t\t\tcolumn( i, breakpoint.name, match[1], match[2]+match[3] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ( match[2] === brokenPoint[0] && ! match[3] ) {\n\t\t\t\t\t\t\t// Class name matched primary breakpoint name with no qualifier\n\t\t\t\t\t\t\tcolumn( i, breakpoint.name, match[1], match[2] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\t// If there was no control class, then automatic sizing is used\n\t\t\tif ( ! hasClass ) {\n\t\t\t\tcol.auto = true;\n\t\t\t}\n\t\t} );\n\n\t\tthis.s.columns = columns;\n\t},\n\n\t/**\n\t * Update the cells to show the correct control class / button\n\t * @private\n\t */\n\t_controlClass: function ()\n\t{\n\t\tif ( this.c.details.type === 'inline' ) {\n\t\t\tvar dt = this.s.dt;\n\t\t\tvar columnsVis = this.s.current;\n\t\t\tvar firstVisible = $.inArray(true, columnsVis);\n\n\t\t\t// Remove from any cells which shouldn't have it\n\t\t\tdt.cells(\n\t\t\t\tnull,\n\t\t\t\tfunction(idx) {\n\t\t\t\t\treturn idx !== firstVisible;\n\t\t\t\t},\n\t\t\t\t{page: 'current'}\n\t\t\t)\n\t\t\t\t.nodes()\n\t\t\t\t.to$()\n\t\t\t\t.filter('.dtr-control')\n\t\t\t\t.removeClass('dtr-control');\n\n\t\t\tdt.cells(null, firstVisible, {page: 'current'})\n\t\t\t\t.nodes()\n\t\t\t\t.to$()\n\t\t\t\t.addClass('dtr-control');\n\t\t}\n\t},\n\n\t/**\n\t * Show the details for the child row\n\t *\n\t * @param  {DataTables.Api} row    API instance for the row\n\t * @param  {boolean}        update Update flag\n\t * @private\n\t */\n\t_detailsDisplay: function ( row, update )\n\t{\n\t\tvar that = this;\n\t\tvar dt = this.s.dt;\n\t\tvar details = this.c.details;\n\n\t\tif ( details && details.type !== false ) {\n\t\t\tvar res = details.display( row, update, function () {\n\t\t\t\treturn details.renderer(\n\t\t\t\t\tdt, row[0], that._detailsObj(row[0])\n\t\t\t\t);\n\t\t\t} );\n\n\t\t\tif ( res === true || res === false ) {\n\t\t\t\t$(dt.table().node()).triggerHandler( 'responsive-display.dt', [dt, row, res, update] );\n\t\t\t}\n\t\t}\n\t},\n\n\n\t/**\n\t * Initialisation for the details handler\n\t *\n\t * @private\n\t */\n\t_detailsInit: function ()\n\t{\n\t\tvar that    = this;\n\t\tvar dt      = this.s.dt;\n\t\tvar details = this.c.details;\n\n\t\t// The inline type always uses the first child as the target\n\t\tif ( details.type === 'inline' ) {\n\t\t\tdetails.target = 'td.dtr-control, th.dtr-control';\n\t\t}\n\n\t\t// Keyboard accessibility\n\t\tdt.on( 'draw.dtr', function () {\n\t\t\tthat._tabIndexes();\n\t\t} );\n\t\tthat._tabIndexes(); // Initial draw has already happened\n\n\t\t$( dt.table().body() ).on( 'keyup.dtr', 'td, th', function (e) {\n\t\t\tif ( e.keyCode === 13 && $(this).data('dtr-keyboard') ) {\n\t\t\t\t$(this).click();\n\t\t\t}\n\t\t} );\n\n\t\t// type.target can be a string jQuery selector or a column index\n\t\tvar target   = details.target;\n\t\tvar selector = typeof target === 'string' ? target : 'td, th';\n\n\t\tif ( target !== undefined || target !== null ) {\n\t\t\t// Click handler to show / hide the details rows when they are available\n\t\t\t$( dt.table().body() )\n\t\t\t\t.on( 'click.dtr mousedown.dtr mouseup.dtr', selector, function (e) {\n\t\t\t\t\t// If the table is not collapsed (i.e. there is no hidden columns)\n\t\t\t\t\t// then take no action\n\t\t\t\t\tif ( ! $(dt.table().node()).hasClass('collapsed' ) ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check that the row is actually a DataTable's controlled node\n\t\t\t\t\tif ( $.inArray( $(this).closest('tr').get(0), dt.rows().nodes().toArray() ) === -1 ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// For column index, we determine if we should act or not in the\n\t\t\t\t\t// handler - otherwise it is already okay\n\t\t\t\t\tif ( typeof target === 'number' ) {\n\t\t\t\t\t\tvar targetIdx = target < 0 ?\n\t\t\t\t\t\t\tdt.columns().eq(0).length + target :\n\t\t\t\t\t\t\ttarget;\n\n\t\t\t\t\t\tif ( dt.cell( this ).index().column !== targetIdx ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// $().closest() includes itself in its check\n\t\t\t\t\tvar row = dt.row( $(this).closest('tr') );\n\n\t\t\t\t\t// Check event type to do an action\n\t\t\t\t\tif ( e.type === 'click' ) {\n\t\t\t\t\t\t// The renderer is given as a function so the caller can execute it\n\t\t\t\t\t\t// only when they need (i.e. if hiding there is no point is running\n\t\t\t\t\t\t// the renderer)\n\t\t\t\t\t\tthat._detailsDisplay( row, false );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( e.type === 'mousedown' ) {\n\t\t\t\t\t\t// For mouse users, prevent the focus ring from showing\n\t\t\t\t\t\t$(this).css('outline', 'none');\n\t\t\t\t\t}\n\t\t\t\t\telse if ( e.type === 'mouseup' ) {\n\t\t\t\t\t\t// And then re-allow at the end of the click\n\t\t\t\t\t\t$(this).trigger('blur').css('outline', '');\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}\n\t},\n\n\n\t/**\n\t * Get the details to pass to a renderer for a row\n\t * @param  {int} rowIdx Row index\n\t * @private\n\t */\n\t_detailsObj: function ( rowIdx )\n\t{\n\t\tvar that = this;\n\t\tvar dt = this.s.dt;\n\n\t\treturn $.map( this.s.columns, function( col, i ) {\n\t\t\t// Never and control columns should not be passed to the renderer\n\t\t\tif ( col.never || col.control ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar dtCol = dt.settings()[0].aoColumns[ i ];\n\n\t\t\treturn {\n\t\t\t\tclassName:   dtCol.sClass,\n\t\t\t\tcolumnIndex: i,\n\t\t\t\tdata:        dt.cell( rowIdx, i ).render( that.c.orthogonal ),\n\t\t\t\thidden:      dt.column( i ).visible() && !that.s.current[ i ],\n\t\t\t\trowIndex:    rowIdx,\n\t\t\t\ttitle:       dtCol.sTitle !== null ?\n\t\t\t\t\tdtCol.sTitle :\n\t\t\t\t\t$(dt.column(i).header()).text()\n\t\t\t};\n\t\t} );\n\t},\n\n\n\t/**\n\t * Find a breakpoint object from a name\n\t *\n\t * @param  {string} name Breakpoint name to find\n\t * @return {object}      Breakpoint description object\n\t * @private\n\t */\n\t_find: function ( name )\n\t{\n\t\tvar breakpoints = this.c.breakpoints;\n\n\t\tfor ( var i=0, ien=breakpoints.length ; i<ien ; i++ ) {\n\t\t\tif ( breakpoints[i].name === name ) {\n\t\t\t\treturn breakpoints[i];\n\t\t\t}\n\t\t}\n\t},\n\n\n\t/**\n\t * Re-create the contents of the child rows as the display has changed in\n\t * some way.\n\t *\n\t * @private\n\t */\n\t_redrawChildren: function ()\n\t{\n\t\tvar that = this;\n\t\tvar dt = this.s.dt;\n\n\t\tdt.rows( {page: 'current'} ).iterator( 'row', function ( settings, idx ) {\n\t\t\tvar row = dt.row( idx );\n\n\t\t\tthat._detailsDisplay( dt.row( idx ), true );\n\t\t} );\n\t},\n\n\n\t/**\n\t * Alter the table display for a resized viewport. This involves first\n\t * determining what breakpoint the window currently is in, getting the\n\t * column visibilities to apply and then setting them.\n\t *\n\t * @param  {boolean} forceRedraw Force a redraw\n\t * @private\n\t */\n\t_resize: function (forceRedraw)\n\t{\n\t\tvar that = this;\n\t\tvar dt = this.s.dt;\n\t\tvar width = $(window).innerWidth();\n\t\tvar breakpoints = this.c.breakpoints;\n\t\tvar breakpoint = breakpoints[0].name;\n\t\tvar columns = this.s.columns;\n\t\tvar i, ien;\n\t\tvar oldVis = this.s.current.slice();\n\n\t\t// Determine what breakpoint we are currently at\n\t\tfor ( i=breakpoints.length-1 ; i>=0 ; i-- ) {\n\t\t\tif ( width <= breakpoints[i].width ) {\n\t\t\t\tbreakpoint = breakpoints[i].name;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Show the columns for that break point\n\t\tvar columnsVis = this._columnsVisiblity( breakpoint );\n\t\tthis.s.current = columnsVis;\n\n\t\t// Set the class before the column visibility is changed so event\n\t\t// listeners know what the state is. Need to determine if there are\n\t\t// any columns that are not visible but can be shown\n\t\tvar collapsedClass = false;\n\t\n\t\tfor ( i=0, ien=columns.length ; i<ien ; i++ ) {\n\t\t\tif ( columnsVis[i] === false && ! columns[i].never && ! columns[i].control && ! dt.column(i).visible() === false ) {\n\t\t\t\tcollapsedClass = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t$( dt.table().node() ).toggleClass( 'collapsed', collapsedClass );\n\n\t\tvar changed = false;\n\t\tvar visible = 0;\n\n\t\tdt.columns().eq(0).each( function ( colIdx, i ) {\n\t\t\tif ( columnsVis[i] === true ) {\n\t\t\t\tvisible++;\n\t\t\t}\n\n\t\t\tif ( forceRedraw || columnsVis[i] !== oldVis[i] ) {\n\t\t\t\tchanged = true;\n\t\t\t\tthat._setColumnVis( colIdx, columnsVis[i] );\n\t\t\t}\n\t\t} );\n\n\t\tif ( changed ) {\n\t\t\tthis._redrawChildren();\n\n\t\t\t// Inform listeners of the change\n\t\t\t$(dt.table().node()).trigger( 'responsive-resize.dt', [dt, this.s.current] );\n\n\t\t\t// If no records, update the \"No records\" display element\n\t\t\tif ( dt.page.info().recordsDisplay === 0 ) {\n\t\t\t\t$('td', dt.table().body()).eq(0).attr('colspan', visible);\n\t\t\t}\n\t\t}\n\n\t\tthat._controlClass();\n\t},\n\n\n\t/**\n\t * Determine the width of each column in the table so the auto column hiding\n\t * has that information to work with. This method is never going to be 100%\n\t * perfect since column widths can change slightly per page, but without\n\t * seriously compromising performance this is quite effective.\n\t *\n\t * @private\n\t */\n\t_resizeAuto: function ()\n\t{\n\t\tvar dt = this.s.dt;\n\t\tvar columns = this.s.columns;\n\n\t\t// Are we allowed to do auto sizing?\n\t\tif ( ! this.c.auto ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Are there any columns that actually need auto-sizing, or do they all\n\t\t// have classes defined\n\t\tif ( $.inArray( true, $.map( columns, function (c) { return c.auto; } ) ) === -1 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Need to restore all children. They will be reinstated by a re-render\n\t\tif ( ! $.isEmptyObject( _childNodeStore ) ) {\n\t\t\t$.each( _childNodeStore, function ( key ) {\n\t\t\t\tvar idx = key.split('-');\n\n\t\t\t\t_childNodesRestore( dt, idx[0]*1, idx[1]*1 );\n\t\t\t} );\n\t\t}\n\n\t\t// Clone the table with the current data in it\n\t\tvar tableWidth   = dt.table().node().offsetWidth;\n\t\tvar columnWidths = dt.columns;\n\t\tvar clonedTable  = dt.table().node().cloneNode( false );\n\t\tvar clonedHeader = $( dt.table().header().cloneNode( false ) ).appendTo( clonedTable );\n\t\tvar clonedBody   = $( dt.table().body() ).clone( false, false ).empty().appendTo( clonedTable ); // use jQuery because of IE8\n\n\t\tclonedTable.style.width = 'auto';\n\n\t\t// Header\n\t\tvar headerCells = dt.columns()\n\t\t\t.header()\n\t\t\t.filter( function (idx) {\n\t\t\t\treturn dt.column(idx).visible();\n\t\t\t} )\n\t\t\t.to$()\n\t\t\t.clone( false )\n\t\t\t.css( 'display', 'table-cell' )\n\t\t\t.css( 'width', 'auto' )\n\t\t\t.css( 'min-width', 0 );\n\n\t\t// Body rows - we don't need to take account of DataTables' column\n\t\t// visibility since we implement our own here (hence the `display` set)\n\t\t$(clonedBody)\n\t\t\t.append( $(dt.rows( { page: 'current' } ).nodes()).clone( false ) )\n\t\t\t.find( 'th, td' ).css( 'display', '' );\n\n\t\t// Footer\n\t\tvar footer = dt.table().footer();\n\t\tif ( footer ) {\n\t\t\tvar clonedFooter = $( footer.cloneNode( false ) ).appendTo( clonedTable );\n\t\t\tvar footerCells = dt.columns()\n\t\t\t\t.footer()\n\t\t\t\t.filter( function (idx) {\n\t\t\t\t\treturn dt.column(idx).visible();\n\t\t\t\t} )\n\t\t\t\t.to$()\n\t\t\t\t.clone( false )\n\t\t\t\t.css( 'display', 'table-cell' );\n\n\t\t\t$('<tr/>')\n\t\t\t\t.append( footerCells )\n\t\t\t\t.appendTo( clonedFooter );\n\t\t}\n\n\t\t$('<tr/>')\n\t\t\t.append( headerCells )\n\t\t\t.appendTo( clonedHeader );\n\n\t\t// In the inline case extra padding is applied to the first column to\n\t\t// give space for the show / hide icon. We need to use this in the\n\t\t// calculation\n\t\tif ( this.c.details.type === 'inline' ) {\n\t\t\t$(clonedTable).addClass( 'dtr-inline collapsed' );\n\t\t}\n\t\t\n\t\t// It is unsafe to insert elements with the same name into the DOM\n\t\t// multiple times. For example, cloning and inserting a checked radio\n\t\t// clears the chcecked state of the original radio.\n\t\t$( clonedTable ).find( '[name]' ).removeAttr( 'name' );\n\n\t\t// A position absolute table would take the table out of the flow of\n\t\t// our container element, bypassing the height and width (Scroller)\n\t\t$( clonedTable ).css( 'position', 'relative' )\n\t\t\n\t\tvar inserted = $('<div/>')\n\t\t\t.css( {\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1,\n\t\t\t\toverflow: 'hidden',\n\t\t\t\tclear: 'both'\n\t\t\t} )\n\t\t\t.append( clonedTable );\n\n\t\tinserted.insertBefore( dt.table().node() );\n\n\t\t// The cloned header now contains the smallest that each column can be\n\t\theaderCells.each( function (i) {\n\t\t\tvar idx = dt.column.index( 'fromVisible', i );\n\t\t\tcolumns[ idx ].minWidth =  this.offsetWidth || 0;\n\t\t} );\n\n\t\tinserted.remove();\n\t},\n\n\t/**\n\t * Get the state of the current hidden columns - controlled by Responsive only\n\t */\n\t_responsiveOnlyHidden: function ()\n\t{\n\t\tvar dt = this.s.dt;\n\n\t\treturn $.map( this.s.current, function (v, i) {\n\t\t\t// If the column is hidden by DataTables then it can't be hidden by\n\t\t\t// Responsive!\n\t\t\tif ( dt.column(i).visible() === false ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn v;\n\t\t} );\n\t},\n\n\t/**\n\t * Set a column's visibility.\n\t *\n\t * We don't use DataTables' column visibility controls in order to ensure\n\t * that column visibility can Responsive can no-exist. Since only IE8+ is\n\t * supported (and all evergreen browsers of course) the control of the\n\t * display attribute works well.\n\t *\n\t * @param {integer} col      Column index\n\t * @param {boolean} showHide Show or hide (true or false)\n\t * @private\n\t */\n\t_setColumnVis: function ( col, showHide )\n\t{\n\t\tvar dt = this.s.dt;\n\t\tvar display = showHide ? '' : 'none'; // empty string will remove the attr\n\n\t\t$( dt.column( col ).header() ).css( 'display', display );\n\t\t$( dt.column( col ).footer() ).css( 'display', display );\n\t\tdt.column( col ).nodes().to$().css( 'display', display );\n\n\t\t// If the are child nodes stored, we might need to reinsert them\n\t\tif ( ! $.isEmptyObject( _childNodeStore ) ) {\n\t\t\tdt.cells( null, col ).indexes().each( function (idx) {\n\t\t\t\t_childNodesRestore( dt, idx.row, idx.column );\n\t\t\t} );\n\t\t}\n\t},\n\n\n\t/**\n\t * Update the cell tab indexes for keyboard accessibility. This is called on\n\t * every table draw - that is potentially inefficient, but also the least\n\t * complex option given that column visibility can change on the fly. Its a\n\t * shame user-focus was removed from CSS 3 UI, as it would have solved this\n\t * issue with a single CSS statement.\n\t *\n\t * @private\n\t */\n\t_tabIndexes: function ()\n\t{\n\t\tvar dt = this.s.dt;\n\t\tvar cells = dt.cells( { page: 'current' } ).nodes().to$();\n\t\tvar ctx = dt.settings()[0];\n\t\tvar target = this.c.details.target;\n\n\t\tcells.filter( '[data-dtr-keyboard]' ).removeData( '[data-dtr-keyboard]' );\n\n\t\tif ( typeof target === 'number' ) {\n\t\t\tdt.cells( null, target, { page: 'current' } ).nodes().to$()\n\t\t\t\t.attr( 'tabIndex', ctx.iTabIndex )\n\t\t\t\t.data( 'dtr-keyboard', 1 );\n\t\t}\n\t\telse {\n\t\t\t// This is a bit of a hack - we need to limit the selected nodes to just\n\t\t\t// those of this table\n\t\t\tif ( target === 'td:first-child, th:first-child' ) {\n\t\t\t\ttarget = '>td:first-child, >th:first-child';\n\t\t\t}\n\n\t\t\t$( target, dt.rows( { page: 'current' } ).nodes() )\n\t\t\t\t.attr( 'tabIndex', ctx.iTabIndex )\n\t\t\t\t.data( 'dtr-keyboard', 1 );\n\t\t}\n\t}\n} );\n\n\n/**\n * List of default breakpoints. Each item in the array is an object with two\n * properties:\n *\n * * `name` - the breakpoint name.\n * * `width` - the breakpoint width\n *\n * @name Responsive.breakpoints\n * @static\n */\nResponsive.breakpoints = [\n\t{ name: 'desktop',  width: Infinity },\n\t{ name: 'tablet-l', width: 1024 },\n\t{ name: 'tablet-p', width: 768 },\n\t{ name: 'mobile-l', width: 480 },\n\t{ name: 'mobile-p', width: 320 }\n];\n\n\n/**\n * Display methods - functions which define how the hidden data should be shown\n * in the table.\n *\n * @namespace\n * @name Responsive.defaults\n * @static\n */\nResponsive.display = {\n\tchildRow: function ( row, update, render ) {\n\t\tif ( update ) {\n\t\t\tif ( $(row.node()).hasClass('parent') ) {\n\t\t\t\trow.child( render(), 'child' ).show();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( ! row.child.isShown()  ) {\n\t\t\t\trow.child( render(), 'child' ).show();\n\t\t\t\t$( row.node() ).addClass( 'parent' );\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\trow.child( false );\n\t\t\t\t$( row.node() ).removeClass( 'parent' );\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t},\n\n\tchildRowImmediate: function ( row, update, render ) {\n\t\tif ( (! update && row.child.isShown()) || ! row.responsive.hasHidden() ) {\n\t\t\t// User interaction and the row is show, or nothing to show\n\t\t\trow.child( false );\n\t\t\t$( row.node() ).removeClass( 'parent' );\n\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\t// Display\n\t\t\trow.child( render(), 'child' ).show();\n\t\t\t$( row.node() ).addClass( 'parent' );\n\n\t\t\treturn true;\n\t\t}\n\t},\n\n\t// This is a wrapper so the modal options for Bootstrap and jQuery UI can\n\t// have options passed into them. This specific one doesn't need to be a\n\t// function but it is for consistency in the `modal` name\n\tmodal: function ( options ) {\n\t\treturn function ( row, update, render ) {\n\t\t\tif ( ! update ) {\n\t\t\t\t// Show a modal\n\t\t\t\tvar close = function () {\n\t\t\t\t\tmodal.remove(); // will tidy events for us\n\t\t\t\t\t$(document).off( 'keypress.dtr' );\n\t\t\t\t};\n\n\t\t\t\tvar modal = $('<div class=\"dtr-modal\"/>')\n\t\t\t\t\t.append( $('<div class=\"dtr-modal-display\"/>')\n\t\t\t\t\t\t.append( $('<div class=\"dtr-modal-content\"/>')\n\t\t\t\t\t\t\t.append( render() )\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.append( $('<div class=\"dtr-modal-close\">&times;</div>' )\n\t\t\t\t\t\t\t.click( function () {\n\t\t\t\t\t\t\t\tclose();\n\t\t\t\t\t\t\t} )\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t\t.append( $('<div class=\"dtr-modal-background\"/>')\n\t\t\t\t\t\t.click( function () {\n\t\t\t\t\t\t\tclose();\n\t\t\t\t\t\t} )\n\t\t\t\t\t)\n\t\t\t\t\t.appendTo( 'body' );\n\n\t\t\t\t$(document).on( 'keyup.dtr', function (e) {\n\t\t\t\t\tif ( e.keyCode === 27 ) {\n\t\t\t\t\t\te.stopPropagation();\n\n\t\t\t\t\t\tclose();\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$('div.dtr-modal-content')\n\t\t\t\t\t.empty()\n\t\t\t\t\t.append( render() );\n\t\t\t}\n\n\t\t\tif ( options && options.header ) {\n\t\t\t\t$('div.dtr-modal-content').prepend(\n\t\t\t\t\t'<h2>'+options.header( row )+'</h2>'\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\t}\n};\n\n\nvar _childNodeStore = {};\n\nfunction _childNodes( dt, row, col ) {\n\tvar name = row+'-'+col;\n\n\tif ( _childNodeStore[ name ] ) {\n\t\treturn _childNodeStore[ name ];\n\t}\n\n\t// https://jsperf.com/childnodes-array-slice-vs-loop\n\tvar nodes = [];\n\tvar children = dt.cell( row, col ).node().childNodes;\n\tfor ( var i=0, ien=children.length ; i<ien ; i++ ) {\n\t\tnodes.push( children[i] );\n\t}\n\n\t_childNodeStore[ name ] = nodes;\n\n\treturn nodes;\n}\n\nfunction _childNodesRestore( dt, row, col ) {\n\tvar name = row+'-'+col;\n\n\tif ( ! _childNodeStore[ name ] ) {\n\t\treturn;\n\t}\n\n\tvar node = dt.cell( row, col ).node();\n\tvar store = _childNodeStore[ name ];\n\tvar parent = store[0].parentNode;\n\tvar parentChildren = parent.childNodes;\n\tvar a = [];\n\n\tfor ( var i=0, ien=parentChildren.length ; i<ien ; i++ ) {\n\t\ta.push( parentChildren[i] );\n\t}\n\n\tfor ( var j=0, jen=a.length ; j<jen ; j++ ) {\n\t\tnode.appendChild( a[j] );\n\t}\n\n\t_childNodeStore[ name ] = undefined;\n}\n\n\n/**\n * Display methods - functions which define how the hidden data should be shown\n * in the table.\n *\n * @namespace\n * @name Responsive.defaults\n * @static\n */\nResponsive.renderer = {\n\tlistHiddenNodes: function () {\n\t\treturn function ( api, rowIdx, columns ) {\n\t\t\tvar ul = $('<ul data-dtr-index=\"'+rowIdx+'\" class=\"dtr-details\"/>');\n\t\t\tvar found = false;\n\n\t\t\tvar data = $.each( columns, function ( i, col ) {\n\t\t\t\tif ( col.hidden ) {\n\t\t\t\t\tvar klass = col.className ?\n\t\t\t\t\t\t'class=\"'+ col.className +'\"' :\n\t\t\t\t\t\t'';\n\t\n\t\t\t\t\t$(\n\t\t\t\t\t\t'<li '+klass+' data-dtr-index=\"'+col.columnIndex+'\" data-dt-row=\"'+col.rowIndex+'\" data-dt-column=\"'+col.columnIndex+'\">'+\n\t\t\t\t\t\t\t'<span class=\"dtr-title\">'+\n\t\t\t\t\t\t\t\tcol.title+\n\t\t\t\t\t\t\t'</span> '+\n\t\t\t\t\t\t'</li>'\n\t\t\t\t\t)\n\t\t\t\t\t\t.append( $('<span class=\"dtr-data\"/>').append( _childNodes( api, col.rowIndex, col.columnIndex ) ) )// api.cell( col.rowIndex, col.columnIndex ).node().childNodes ) )\n\t\t\t\t\t\t.appendTo( ul );\n\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\treturn found ?\n\t\t\t\tul :\n\t\t\t\tfalse;\n\t\t};\n\t},\n\n\tlistHidden: function () {\n\t\treturn function ( api, rowIdx, columns ) {\n\t\t\tvar data = $.map( columns, function ( col ) {\n\t\t\t\tvar klass = col.className ?\n\t\t\t\t\t'class=\"'+ col.className +'\"' :\n\t\t\t\t\t'';\n\n\t\t\t\treturn col.hidden ?\n\t\t\t\t\t'<li '+klass+' data-dtr-index=\"'+col.columnIndex+'\" data-dt-row=\"'+col.rowIndex+'\" data-dt-column=\"'+col.columnIndex+'\">'+\n\t\t\t\t\t\t'<span class=\"dtr-title\">'+\n\t\t\t\t\t\t\tcol.title+\n\t\t\t\t\t\t'</span> '+\n\t\t\t\t\t\t'<span class=\"dtr-data\">'+\n\t\t\t\t\t\t\tcol.data+\n\t\t\t\t\t\t'</span>'+\n\t\t\t\t\t'</li>' :\n\t\t\t\t\t'';\n\t\t\t} ).join('');\n\n\t\t\treturn data ?\n\t\t\t\t$('<ul data-dtr-index=\"'+rowIdx+'\" class=\"dtr-details\"/>').append( data ) :\n\t\t\t\tfalse;\n\t\t}\n\t},\n\n\ttableAll: function ( options ) {\n\t\toptions = $.extend( {\n\t\t\ttableClass: ''\n\t\t}, options );\n\n\t\treturn function ( api, rowIdx, columns ) {\n\t\t\tvar data = $.map( columns, function ( col ) {\n\t\t\t\tvar klass = col.className ?\n\t\t\t\t\t'class=\"'+ col.className +'\"' :\n\t\t\t\t\t'';\n\n\t\t\t\treturn '<tr '+klass+' data-dt-row=\"'+col.rowIndex+'\" data-dt-column=\"'+col.columnIndex+'\">'+\n\t\t\t\t\t\t'<td>'+col.title+':'+'</td> '+\n\t\t\t\t\t\t'<td>'+col.data+'</td>'+\n\t\t\t\t\t'</tr>';\n\t\t\t} ).join('');\n\n\t\t\treturn $('<table class=\"'+options.tableClass+' dtr-details\" width=\"100%\"/>').append( data );\n\t\t}\n\t}\n};\n\n/**\n * Responsive default settings for initialisation\n *\n * @namespace\n * @name Responsive.defaults\n * @static\n */\nResponsive.defaults = {\n\t/**\n\t * List of breakpoints for the instance. Note that this means that each\n\t * instance can have its own breakpoints. Additionally, the breakpoints\n\t * cannot be changed once an instance has been creased.\n\t *\n\t * @type {Array}\n\t * @default Takes the value of `Responsive.breakpoints`\n\t */\n\tbreakpoints: Responsive.breakpoints,\n\n\t/**\n\t * Enable / disable auto hiding calculations. It can help to increase\n\t * performance slightly if you disable this option, but all columns would\n\t * need to have breakpoint classes assigned to them\n\t *\n\t * @type {Boolean}\n\t * @default  `true`\n\t */\n\tauto: true,\n\n\t/**\n\t * Details control. If given as a string value, the `type` property of the\n\t * default object is set to that value, and the defaults used for the rest\n\t * of the object - this is for ease of implementation.\n\t *\n\t * The object consists of the following properties:\n\t *\n\t * * `display` - A function that is used to show and hide the hidden details\n\t * * `renderer` - function that is called for display of the child row data.\n\t *   The default function will show the data from the hidden columns\n\t * * `target` - Used as the selector for what objects to attach the child\n\t *   open / close to\n\t * * `type` - `false` to disable the details display, `inline` or `column`\n\t *   for the two control types\n\t *\n\t * @type {Object|string}\n\t */\n\tdetails: {\n\t\tdisplay: Responsive.display.childRow,\n\n\t\trenderer: Responsive.renderer.listHidden(),\n\n\t\ttarget: 0,\n\n\t\ttype: 'inline'\n\t},\n\n\t/**\n\t * Orthogonal data request option. This is used to define the data type\n\t * requested when Responsive gets the data to show in the child row.\n\t *\n\t * @type {String}\n\t */\n\torthogonal: 'display'\n};\n\n\n/*\n * API\n */\nvar Api = $.fn.dataTable.Api;\n\n// Doesn't do anything - work around for a bug in DT... Not documented\nApi.register( 'responsive()', function () {\n\treturn this;\n} );\n\nApi.register( 'responsive.index()', function ( li ) {\n\tli = $(li);\n\n\treturn {\n\t\tcolumn: li.data('dtr-index'),\n\t\trow:    li.parent().data('dtr-index')\n\t};\n} );\n\nApi.register( 'responsive.rebuild()', function () {\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tif ( ctx._responsive ) {\n\t\t\tctx._responsive._classLogic();\n\t\t}\n\t} );\n} );\n\nApi.register( 'responsive.recalc()', function () {\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tif ( ctx._responsive ) {\n\t\t\tctx._responsive._resizeAuto();\n\t\t\tctx._responsive._resize();\n\t\t}\n\t} );\n} );\n\nApi.register( 'responsive.hasHidden()', function () {\n\tvar ctx = this.context[0];\n\n\treturn ctx._responsive ?\n\t\t$.inArray( false, ctx._responsive._responsiveOnlyHidden() ) !== -1 :\n\t\tfalse;\n} );\n\nApi.registerPlural( 'columns().responsiveHidden()', 'column().responsiveHidden()', function () {\n\treturn this.iterator( 'column', function ( settings, column ) {\n\t\treturn settings._responsive ?\n\t\t\tsettings._responsive._responsiveOnlyHidden()[ column ] :\n\t\t\tfalse;\n\t}, 1 );\n} );\n\n\n/**\n * Version information\n *\n * @name Responsive.version\n * @static\n */\nResponsive.version = '2.2.9';\n\n\n$.fn.dataTable.Responsive = Responsive;\n$.fn.DataTable.Responsive = Responsive;\n\n// Attach a listener to the document which listens for DataTables initialisation\n// events so we can automatically initialise\n$(document).on( 'preInit.dt.dtr', function (e, settings, json) {\n\tif ( e.namespace !== 'dt' ) {\n\t\treturn;\n\t}\n\n\tif ( $(settings.nTable).hasClass( 'responsive' ) ||\n\t\t $(settings.nTable).hasClass( 'dt-responsive' ) ||\n\t\t settings.oInit.responsive ||\n\t\t DataTable.defaults.responsive\n\t) {\n\t\tvar init = settings.oInit.responsive;\n\n\t\tif ( init !== false ) {\n\t\t\tnew Responsive( settings, $.isPlainObject( init ) ? init : {}  );\n\t\t}\n\t}\n} );\n\n\nreturn Responsive;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtcmVzcG9uc2l2ZS9qcy9kYXRhVGFibGVzLnJlc3BvbnNpdmUuanM/ODBkOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBMEM7QUFDaEQ7QUFDQSxFQUFFLGlDQUFRLENBQUMsMkNBQVEsRUFBRSwyREFBZ0IsQ0FBQyxtQ0FBRTtBQUN4QztBQUNBLEdBQUc7QUFBQSxvR0FBRTtBQUNMO0FBQ0EsTUFBTSxFQWlCSjtBQUNGLENBQUM7QUFDRDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7O0FBRUEsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtcmVzcG9uc2l2ZS9qcy9kYXRhVGFibGVzLnJlc3BvbnNpdmUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgUmVzcG9uc2l2ZSAyLjIuOVxuICogMjAxNC0yMDIxIFNwcnlNZWRpYSBMdGQgLSBkYXRhdGFibGVzLm5ldC9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBAc3VtbWFyeSAgICAgUmVzcG9uc2l2ZVxuICogQGRlc2NyaXB0aW9uIFJlc3BvbnNpdmUgdGFibGVzIHBsdWctaW4gZm9yIERhdGFUYWJsZXNcbiAqIEB2ZXJzaW9uICAgICAyLjIuOVxuICogQGZpbGUgICAgICAgIGRhdGFUYWJsZXMucmVzcG9uc2l2ZS5qc1xuICogQGF1dGhvciAgICAgIFNwcnlNZWRpYSBMdGQgKHd3dy5zcHJ5bWVkaWEuY28udWspXG4gKiBAY29udGFjdCAgICAgd3d3LnNwcnltZWRpYS5jby51ay9jb250YWN0XG4gKiBAY29weXJpZ2h0ICAgQ29weXJpZ2h0IDIwMTQtMjAyMSBTcHJ5TWVkaWEgTHRkLlxuICpcbiAqIFRoaXMgc291cmNlIGZpbGUgaXMgZnJlZSBzb2Z0d2FyZSwgYXZhaWxhYmxlIHVuZGVyIHRoZSBmb2xsb3dpbmcgbGljZW5zZTpcbiAqICAgTUlUIGxpY2Vuc2UgLSBodHRwOi8vZGF0YXRhYmxlcy5uZXQvbGljZW5zZS9taXRcbiAqXG4gKiBUaGlzIHNvdXJjZSBmaWxlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dFxuICogV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAqIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIGxpY2Vuc2UgZmlsZXMgZm9yIGRldGFpbHMuXG4gKlxuICogRm9yIGRldGFpbHMgcGxlYXNlIHJlZmVyIHRvOiBodHRwOi8vd3d3LmRhdGF0YWJsZXMubmV0XG4gKi9cbihmdW5jdGlvbiggZmFjdG9yeSApe1xuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoIFsnanF1ZXJ5JywgJ2RhdGF0YWJsZXMubmV0J10sIGZ1bmN0aW9uICggJCApIHtcblx0XHRcdHJldHVybiBmYWN0b3J5KCAkLCB3aW5kb3csIGRvY3VtZW50ICk7XG5cdFx0fSApO1xuXHR9XG5cdGVsc2UgaWYgKCB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290LCAkKSB7XG5cdFx0XHRpZiAoICEgcm9vdCApIHtcblx0XHRcdFx0cm9vdCA9IHdpbmRvdztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhICQgfHwgISAkLmZuLmRhdGFUYWJsZSApIHtcblx0XHRcdFx0JCA9IHJlcXVpcmUoJ2RhdGF0YWJsZXMubmV0Jykocm9vdCwgJCkuJDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhY3RvcnkoICQsIHJvb3QsIHJvb3QuZG9jdW1lbnQgKTtcblx0XHR9O1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEJyb3dzZXJcblx0XHRmYWN0b3J5KCBqUXVlcnksIHdpbmRvdywgZG9jdW1lbnQgKTtcblx0fVxufShmdW5jdGlvbiggJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkICkge1xuJ3VzZSBzdHJpY3QnO1xudmFyIERhdGFUYWJsZSA9ICQuZm4uZGF0YVRhYmxlO1xuXG5cbi8qKlxuICogUmVzcG9uc2l2ZSBpcyBhIHBsdWctaW4gZm9yIHRoZSBEYXRhVGFibGVzIGxpYnJhcnkgdGhhdCBtYWtlcyB1c2Ugb2ZcbiAqIERhdGFUYWJsZXMnIGFiaWxpdHkgdG8gY2hhbmdlIHRoZSB2aXNpYmlsaXR5IG9mIGNvbHVtbnMsIGNoYW5naW5nIHRoZVxuICogdmlzaWJpbGl0eSBvZiBjb2x1bW5zIHNvIHRoZSBkaXNwbGF5ZWQgY29sdW1ucyBmaXQgaW50byB0aGUgdGFibGUgY29udGFpbmVyLlxuICogVGhlIGVuZCByZXN1bHQgaXMgdGhhdCBjb21wbGV4IHRhYmxlcyB3aWxsIGJlIGR5bmFtaWNhbGx5IGFkanVzdGVkIHRvIGZpdFxuICogaW50byB0aGUgdmlld3BvcnQsIGJlIGl0IG9uIGEgZGVza3RvcCwgdGFibGV0IG9yIG1vYmlsZSBicm93c2VyLlxuICpcbiAqIFJlc3BvbnNpdmUgZm9yIERhdGFUYWJsZXMgaGFzIHR3byBtb2RlcyBvZiBvcGVyYXRpb24sIHdoaWNoIGNhbiB1c2VkXG4gKiBpbmRpdmlkdWFsbHkgb3IgY29tYmluZWQ6XG4gKlxuICogKiBDbGFzcyBuYW1lIGJhc2VkIGNvbnRyb2wgLSBjb2x1bW5zIGFzc2lnbmVkIGNsYXNzIG5hbWVzIHRoYXQgbWF0Y2ggdGhlXG4gKiAgIGJyZWFrcG9pbnQgbG9naWMgY2FuIGJlIHNob3duIC8gaGlkZGVuIGFzIHJlcXVpcmVkIGZvciBlYWNoIGJyZWFrcG9pbnQuXG4gKiAqIEF1dG9tYXRpYyBjb250cm9sIC0gY29sdW1ucyBhcmUgYXV0b21hdGljYWxseSBoaWRkZW4gd2hlbiB0aGVyZSBpcyBub1xuICogICByb29tIGxlZnQgdG8gZGlzcGxheSB0aGVtLiBDb2x1bW5zIHJlbW92ZWQgZnJvbSB0aGUgcmlnaHQuXG4gKlxuICogSW4gYWRkaXRpb25hbCB0byBjb2x1bW4gdmlzaWJpbGl0eSBjb250cm9sLCBSZXNwb25zaXZlIGFsc28gaGFzIGJ1aWx0IGludG9cbiAqIG9wdGlvbnMgdG8gdXNlIERhdGFUYWJsZXMnIGNoaWxkIHJvdyBkaXNwbGF5IHRvIHNob3cgLyBoaWRlIHRoZSBpbmZvcm1hdGlvblxuICogZnJvbSB0aGUgdGFibGUgdGhhdCBoYXMgYmVlbiBoaWRkZW4uIFRoZXJlIGFyZSBhbHNvIHR3byBtb2RlcyBvZiBvcGVyYXRpb25cbiAqIGZvciB0aGlzIGNoaWxkIHJvdyBkaXNwbGF5OlxuICpcbiAqICogSW5saW5lIC0gd2hlbiB0aGUgY29udHJvbCBlbGVtZW50IHRoYXQgdGhlIHVzZXIgY2FuIHVzZSB0byBzaG93IC8gaGlkZVxuICogICBjaGlsZCByb3dzIGlzIGRpc3BsYXllZCBpbnNpZGUgdGhlIGZpcnN0IGNvbHVtbiBvZiB0aGUgdGFibGUuXG4gKiAqIENvbHVtbiAtIHdoZXJlIGEgd2hvbGUgY29sdW1uIGlzIGRlZGljYXRlZCB0byBiZSB0aGUgc2hvdyAvIGhpZGUgY29udHJvbC5cbiAqXG4gKiBJbml0aWFsaXNhdGlvbiBvZiBSZXNwb25zaXZlIGlzIHBlcmZvcm1lZCBieTpcbiAqXG4gKiAqIEFkZGluZyB0aGUgY2xhc3MgYHJlc3BvbnNpdmVgIG9yIGBkdC1yZXNwb25zaXZlYCB0byB0aGUgdGFibGUuIEluIHRoaXMgY2FzZVxuICogICBSZXNwb25zaXZlIHdpbGwgYXV0b21hdGljYWxseSBiZSBpbml0aWFsaXNlZCB3aXRoIHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb25cbiAqICAgb3B0aW9ucyB3aGVuIHRoZSBEYXRhVGFibGUgaXMgY3JlYXRlZC5cbiAqICogVXNpbmcgdGhlIGByZXNwb25zaXZlYCBvcHRpb24gaW4gdGhlIERhdGFUYWJsZXMgY29uZmlndXJhdGlvbiBvcHRpb25zLiBUaGlzXG4gKiAgIGNhbiBhbHNvIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgY29uZmlndXJhdGlvbiBvcHRpb25zLCBvciBzaW1wbHkgc2V0IHRvXG4gKiAgIGB0cnVlYCB0byB1c2UgdGhlIGRlZmF1bHRzLlxuICpcbiAqICBAY2xhc3NcbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3QgZm9yIHRoZSBob3N0IHRhYmxlXG4gKiAgQHBhcmFtIHtvYmplY3R9IFtvcHRzXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqICBAcmVxdWlyZXMgalF1ZXJ5IDEuNytcbiAqICBAcmVxdWlyZXMgRGF0YVRhYmxlcyAxLjEwLjMrXG4gKlxuICogIEBleGFtcGxlXG4gKiAgICAgICQoJyNleGFtcGxlJykuRGF0YVRhYmxlKCB7XG4gKiAgICAgICAgcmVzcG9uc2l2ZTogdHJ1ZVxuICogICAgICB9ICk7XG4gKiAgICB9ICk7XG4gKi9cbnZhciBSZXNwb25zaXZlID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgb3B0cyApIHtcblx0Ly8gU2FuaXR5IGNoZWNrIHRoYXQgd2UgYXJlIHVzaW5nIERhdGFUYWJsZXMgMS4xMCBvciBuZXdlclxuXHRpZiAoICEgRGF0YVRhYmxlLnZlcnNpb25DaGVjayB8fCAhIERhdGFUYWJsZS52ZXJzaW9uQ2hlY2soICcxLjEwLjEwJyApICkge1xuXHRcdHRocm93ICdEYXRhVGFibGVzIFJlc3BvbnNpdmUgcmVxdWlyZXMgRGF0YVRhYmxlcyAxLjEwLjEwIG9yIG5ld2VyJztcblx0fVxuXG5cdHRoaXMucyA9IHtcblx0XHRkdDogbmV3IERhdGFUYWJsZS5BcGkoIHNldHRpbmdzICksXG5cdFx0Y29sdW1uczogW10sXG5cdFx0Y3VycmVudDogW11cblx0fTtcblxuXHQvLyBDaGVjayBpZiByZXNwb25zaXZlIGhhcyBhbHJlYWR5IGJlZW4gaW5pdGlhbGlzZWQgb24gdGhpcyB0YWJsZVxuXHRpZiAoIHRoaXMucy5kdC5zZXR0aW5ncygpWzBdLnJlc3BvbnNpdmUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gZGV0YWlscyBpcyBhbiBvYmplY3QsIGJ1dCBmb3Igc2ltcGxpY2l0eSB0aGUgdXNlciBjYW4gZ2l2ZSBpdCBhcyBhIHN0cmluZ1xuXHQvLyBvciBhIGJvb2xlYW5cblx0aWYgKCBvcHRzICYmIHR5cGVvZiBvcHRzLmRldGFpbHMgPT09ICdzdHJpbmcnICkge1xuXHRcdG9wdHMuZGV0YWlscyA9IHsgdHlwZTogb3B0cy5kZXRhaWxzIH07XG5cdH1cblx0ZWxzZSBpZiAoIG9wdHMgJiYgb3B0cy5kZXRhaWxzID09PSBmYWxzZSApIHtcblx0XHRvcHRzLmRldGFpbHMgPSB7IHR5cGU6IGZhbHNlIH07XG5cdH1cblx0ZWxzZSBpZiAoIG9wdHMgJiYgb3B0cy5kZXRhaWxzID09PSB0cnVlICkge1xuXHRcdG9wdHMuZGV0YWlscyA9IHsgdHlwZTogJ2lubGluZScgfTtcblx0fVxuXG5cdHRoaXMuYyA9ICQuZXh0ZW5kKCB0cnVlLCB7fSwgUmVzcG9uc2l2ZS5kZWZhdWx0cywgRGF0YVRhYmxlLmRlZmF1bHRzLnJlc3BvbnNpdmUsIG9wdHMgKTtcblx0c2V0dGluZ3MucmVzcG9uc2l2ZSA9IHRoaXM7XG5cdHRoaXMuX2NvbnN0cnVjdG9yKCk7XG59O1xuXG4kLmV4dGVuZCggUmVzcG9uc2l2ZS5wcm90b3R5cGUsIHtcblx0LyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuXHQgKiBDb25zdHJ1Y3RvclxuXHQgKi9cblxuXHQvKipcblx0ICogSW5pdGlhbGlzZSB0aGUgUmVzcG9uc2l2ZSBpbnN0YW5jZVxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2NvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdHZhciBkdCA9IHRoaXMucy5kdDtcblx0XHR2YXIgZHRQcml2YXRlU2V0dGluZ3MgPSBkdC5zZXR0aW5ncygpWzBdO1xuXHRcdHZhciBvbGRXaW5kb3dXaWR0aCA9ICQod2luZG93KS5pbm5lcldpZHRoKCk7XG5cblx0XHRkdC5zZXR0aW5ncygpWzBdLl9yZXNwb25zaXZlID0gdGhpcztcblxuXHRcdC8vIFVzZSBEYXRhVGFibGVzJyB0aHJvdHRsZSBmdW5jdGlvbiB0byBhdm9pZCBwcm9jZXNzb3IgdGhyYXNoaW5nIG9uXG5cdFx0Ly8gcmVzaXplXG5cdFx0JCh3aW5kb3cpLm9uKCAncmVzaXplLmR0ciBvcmllbnRhdGlvbmNoYW5nZS5kdHInLCBEYXRhVGFibGUudXRpbC50aHJvdHRsZSggZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gaU9TIGhhcyBhIGJ1ZyB3aGVyZWJ5IHJlc2l6ZSBjYW4gZmlyZSB3aGVuIG9ubHkgc2Nyb2xsaW5nXG5cdFx0XHQvLyBTZWU6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODg5ODQxMlxuXHRcdFx0dmFyIHdpZHRoID0gJCh3aW5kb3cpLmlubmVyV2lkdGgoKTtcblxuXHRcdFx0aWYgKCB3aWR0aCAhPT0gb2xkV2luZG93V2lkdGggKSB7XG5cdFx0XHRcdHRoYXQuX3Jlc2l6ZSgpO1xuXHRcdFx0XHRvbGRXaW5kb3dXaWR0aCA9IHdpZHRoO1xuXHRcdFx0fVxuXHRcdH0gKSApO1xuXG5cdFx0Ly8gRGF0YVRhYmxlcyBkb2Vzbid0IGN1cnJlbnRseSB0cmlnZ2VyIGFuIGV2ZW50IHdoZW4gYSByb3cgaXMgYWRkZWQsIHNvXG5cdFx0Ly8gd2UgbmVlZCB0byBob29rIGludG8gaXRzIHByaXZhdGUgQVBJIHRvIGVuZm9yY2UgdGhlIGhpZGRlbiByb3dzIHdoZW5cblx0XHQvLyBuZXcgZGF0YSBpcyBhZGRlZFxuXHRcdGR0UHJpdmF0ZVNldHRpbmdzLm9BcGkuX2ZuQ2FsbGJhY2tSZWcoIGR0UHJpdmF0ZVNldHRpbmdzLCAnYW9Sb3dDcmVhdGVkQ2FsbGJhY2snLCBmdW5jdGlvbiAodHIsIGRhdGEsIGlkeCkge1xuXHRcdFx0aWYgKCAkLmluQXJyYXkoIGZhbHNlLCB0aGF0LnMuY3VycmVudCApICE9PSAtMSApIHtcblx0XHRcdFx0JCgnPnRkLCA+dGgnLCB0cikuZWFjaCggZnVuY3Rpb24gKCBpICkge1xuXHRcdFx0XHRcdHZhciBpZHggPSBkdC5jb2x1bW4uaW5kZXgoICd0b0RhdGEnLCBpICk7XG5cblx0XHRcdFx0XHRpZiAoIHRoYXQucy5jdXJyZW50W2lkeF0gPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0JCh0aGlzKS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdC8vIERlc3Ryb3kgZXZlbnQgaGFuZGxlclxuXHRcdGR0Lm9uKCAnZGVzdHJveS5kdHInLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRkdC5vZmYoICcuZHRyJyApO1xuXHRcdFx0JCggZHQudGFibGUoKS5ib2R5KCkgKS5vZmYoICcuZHRyJyApO1xuXHRcdFx0JCh3aW5kb3cpLm9mZiggJ3Jlc2l6ZS5kdHIgb3JpZW50YXRpb25jaGFuZ2UuZHRyJyApO1xuXHRcdFx0ZHQuY2VsbHMoJy5kdHItY29udHJvbCcpLm5vZGVzKCkudG8kKCkucmVtb3ZlQ2xhc3MoJ2R0ci1jb250cm9sJyk7XG5cblx0XHRcdC8vIFJlc3RvcmUgdGhlIGNvbHVtbnMgdGhhdCB3ZSd2ZSBoaWRkZW5cblx0XHRcdCQuZWFjaCggdGhhdC5zLmN1cnJlbnQsIGZ1bmN0aW9uICggaSwgdmFsICkge1xuXHRcdFx0XHRpZiAoIHZhbCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0dGhhdC5fc2V0Q29sdW1uVmlzKCBpLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cblx0XHQvLyBSZW9yZGVyIHRoZSBicmVha3BvaW50cyBhcnJheSBoZXJlIGluIGNhc2UgdGhleSBoYXZlIGJlZW4gYWRkZWQgb3V0XG5cdFx0Ly8gb2Ygb3JkZXJcblx0XHR0aGlzLmMuYnJlYWtwb2ludHMuc29ydCggZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdHJldHVybiBhLndpZHRoIDwgYi53aWR0aCA/IDEgOlxuXHRcdFx0XHRhLndpZHRoID4gYi53aWR0aCA/IC0xIDogMDtcblx0XHR9ICk7XG5cblx0XHR0aGlzLl9jbGFzc0xvZ2ljKCk7XG5cdFx0dGhpcy5fcmVzaXplQXV0bygpO1xuXG5cdFx0Ly8gRGV0YWlscyBoYW5kbGVyXG5cdFx0dmFyIGRldGFpbHMgPSB0aGlzLmMuZGV0YWlscztcblxuXHRcdGlmICggZGV0YWlscy50eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHRoYXQuX2RldGFpbHNJbml0KCk7XG5cblx0XHRcdC8vIERhdGFUYWJsZXMgd2lsbCB0cmlnZ2VyIHRoaXMgZXZlbnQgb24gZXZlcnkgY29sdW1uIGl0IHNob3dzIGFuZFxuXHRcdFx0Ly8gaGlkZXMgaW5kaXZpZHVhbGx5XG5cdFx0XHRkdC5vbiggJ2NvbHVtbi12aXNpYmlsaXR5LmR0cicsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Ly8gVXNlIGEgc21hbGwgZGVib3VuY2UgdG8gYWxsb3cgbXVsdGlwbGUgY29sdW1ucyB0byBiZSBzZXQgdG9nZXRoZXJcblx0XHRcdFx0aWYgKCB0aGF0Ll90aW1lciApIHtcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQoIHRoYXQuX3RpbWVyICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGF0Ll90aW1lciA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0aGF0Ll90aW1lciA9IG51bGw7XG5cblx0XHRcdFx0XHR0aGF0Ll9jbGFzc0xvZ2ljKCk7XG5cdFx0XHRcdFx0dGhhdC5fcmVzaXplQXV0bygpO1xuXHRcdFx0XHRcdHRoYXQuX3Jlc2l6ZSh0cnVlKTtcblxuXHRcdFx0XHRcdHRoYXQuX3JlZHJhd0NoaWxkcmVuKCk7XG5cdFx0XHRcdH0sIDEwMCApO1xuXHRcdFx0fSApO1xuXG5cdFx0XHQvLyBSZWRyYXcgdGhlIGRldGFpbHMgYm94IG9uIGVhY2ggZHJhdyB3aGljaCB3aWxsIGhhcHBlbiBpZiB0aGUgZGF0YVxuXHRcdFx0Ly8gaGFzIGNoYW5nZWQuIFRoaXMgaXMgdXNlZCB1bnRpbCBEYXRhVGFibGVzIGltcGxlbWVudHMgYSBuYXRpdmVcblx0XHRcdC8vIGB1cGRhdGVkYCBldmVudCBmb3Igcm93c1xuXHRcdFx0ZHQub24oICdkcmF3LmR0cicsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhhdC5fcmVkcmF3Q2hpbGRyZW4oKTtcblx0XHRcdH0gKTtcblxuXHRcdFx0JChkdC50YWJsZSgpLm5vZGUoKSkuYWRkQ2xhc3MoICdkdHItJytkZXRhaWxzLnR5cGUgKTtcblx0XHR9XG5cblx0XHRkdC5vbiggJ2NvbHVtbi1yZW9yZGVyLmR0cicsIGZ1bmN0aW9uIChlLCBzZXR0aW5ncywgZGV0YWlscykge1xuXHRcdFx0dGhhdC5fY2xhc3NMb2dpYygpO1xuXHRcdFx0dGhhdC5fcmVzaXplQXV0bygpO1xuXHRcdFx0dGhhdC5fcmVzaXplKHRydWUpO1xuXHRcdH0gKTtcblxuXHRcdC8vIENoYW5nZSBpbiBjb2x1bW4gc2l6ZXMgbWVhbnMgd2UgbmVlZCB0byBjYWxjXG5cdFx0ZHQub24oICdjb2x1bW4tc2l6aW5nLmR0cicsIGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoYXQuX3Jlc2l6ZUF1dG8oKTtcblx0XHRcdHRoYXQuX3Jlc2l6ZSgpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gT24gQWpheCByZWxvYWQgd2Ugd2FudCB0byByZW9wZW4gYW55IGNoaWxkIHJvd3Mgd2hpY2ggYXJlIGRpc3BsYXllZFxuXHRcdC8vIGJ5IHJlc3BvbnNpdmVcblx0XHRkdC5vbiggJ3ByZVhoci5kdHInLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgcm93SWRzID0gW107XG5cdFx0XHRkdC5yb3dzKCkuZXZlcnkoIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKCB0aGlzLmNoaWxkLmlzU2hvd24oKSApIHtcblx0XHRcdFx0XHRyb3dJZHMucHVzaCggdGhpcy5pZCh0cnVlKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cblx0XHRcdGR0Lm9uZSggJ2RyYXcuZHRyJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGF0Ll9yZXNpemVBdXRvKCk7XG5cdFx0XHRcdHRoYXQuX3Jlc2l6ZSgpO1xuXG5cdFx0XHRcdGR0LnJvd3MoIHJvd0lkcyApLmV2ZXJ5KCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dGhhdC5fZGV0YWlsc0Rpc3BsYXkoIHRoaXMsIGZhbHNlICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH0gKTtcblx0XHR9KTtcblxuXHRcdGR0XG5cdFx0XHQub24oICdkcmF3LmR0cicsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhhdC5fY29udHJvbENsYXNzKCk7XG5cdFx0XHR9KVxuXHRcdFx0Lm9uKCAnaW5pdC5kdHInLCBmdW5jdGlvbiAoZSwgc2V0dGluZ3MsIGRldGFpbHMpIHtcblx0XHRcdFx0aWYgKCBlLm5hbWVzcGFjZSAhPT0gJ2R0JyApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGF0Ll9yZXNpemVBdXRvKCk7XG5cdFx0XHRcdHRoYXQuX3Jlc2l6ZSgpO1xuXG5cdFx0XHRcdC8vIElmIGNvbHVtbnMgd2VyZSBoaWRkZW4sIHRoZW4gRGF0YVRhYmxlcyBuZWVkcyB0byBhZGp1c3QgdGhlXG5cdFx0XHRcdC8vIGNvbHVtbiBzaXppbmdcblx0XHRcdFx0aWYgKCAkLmluQXJyYXkoIGZhbHNlLCB0aGF0LnMuY3VycmVudCApICkge1xuXHRcdFx0XHRcdGR0LmNvbHVtbnMuYWRqdXN0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblxuXHRcdC8vIEZpcnN0IHBhc3MgLSBkcmF3IHRoZSB0YWJsZSBmb3IgdGhlIGN1cnJlbnQgdmlld3BvcnQgc2l6ZVxuXHRcdHRoaXMuX3Jlc2l6ZSgpO1xuXHR9LFxuXG5cblx0LyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuXHQgKiBQcml2YXRlIG1ldGhvZHNcblx0ICovXG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZSB0aGUgdmlzaWJpbGl0eSBmb3IgdGhlIGNvbHVtbnMgaW4gYSB0YWJsZSBmb3IgYSBnaXZlblxuXHQgKiBicmVha3BvaW50LiBUaGUgcmVzdWx0IGlzIHByZS1kZXRlcm1pbmVkIGJhc2VkIG9uIHRoZSBjbGFzcyBsb2dpYyBpZlxuXHQgKiBjbGFzcyBuYW1lcyBhcmUgdXNlZCB0byBjb250cm9sIGFsbCBjb2x1bW5zLCBidXQgdGhlIHdpZHRoIG9mIHRoZSB0YWJsZVxuXHQgKiBpcyBhbHNvIHVzZWQgaWYgdGhlcmUgYXJlIGNvbHVtbnMgd2hpY2ggYXJlIHRvIGJlIGF1dG9tYXRpY2FsbHkgc2hvd25cblx0ICogYW5kIGhpZGRlbi5cblx0ICpcblx0ICogQHBhcmFtICB7c3RyaW5nfSBicmVha3BvaW50IEJyZWFrcG9pbnQgbmFtZSB0byB1c2UgZm9yIHRoZSBjYWxjdWxhdGlvblxuXHQgKiBAcmV0dXJuIHthcnJheX0gQXJyYXkgb2YgYm9vbGVhbiB2YWx1ZXMgaW5pdGlhdGluZyB0aGUgdmlzaWJpbGl0eSBvZiBlYWNoXG5cdCAqICAgY29sdW1uLlxuXHQgKiAgQHByaXZhdGVcblx0ICovXG5cdF9jb2x1bW5zVmlzaWJsaXR5OiBmdW5jdGlvbiAoIGJyZWFrcG9pbnQgKVxuXHR7XG5cdFx0dmFyIGR0ID0gdGhpcy5zLmR0O1xuXHRcdHZhciBjb2x1bW5zID0gdGhpcy5zLmNvbHVtbnM7XG5cdFx0dmFyIGksIGllbjtcblxuXHRcdC8vIENyZWF0ZSBhbiBhcnJheSB0aGF0IGRlZmluZXMgdGhlIGNvbHVtbiBvcmRlcmluZyBiYXNlZCBmaXJzdCBvbiB0aGVcblx0XHQvLyBjb2x1bW4ncyBwcmlvcml0eSwgYW5kIHNlY29uZGx5IHRoZSBjb2x1bW4gaW5kZXguIFRoaXMgYWxsb3dzIHRoZVxuXHRcdC8vIGNvbHVtbnMgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSByaWdodCBpZiB0aGUgcHJpb3JpdHkgbWF0Y2hlc1xuXHRcdHZhciBvcmRlciA9IGNvbHVtbnNcblx0XHRcdC5tYXAoIGZ1bmN0aW9uICggY29sLCBpZHggKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0Y29sdW1uSWR4OiBpZHgsXG5cdFx0XHRcdFx0cHJpb3JpdHk6IGNvbC5wcmlvcml0eVxuXHRcdFx0XHR9O1xuXHRcdFx0fSApXG5cdFx0XHQuc29ydCggZnVuY3Rpb24gKCBhLCBiICkge1xuXHRcdFx0XHRpZiAoIGEucHJpb3JpdHkgIT09IGIucHJpb3JpdHkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBhLmNvbHVtbklkeCAtIGIuY29sdW1uSWR4O1xuXHRcdFx0fSApO1xuXG5cdFx0Ly8gQ2xhc3MgbG9naWMgLSBkZXRlcm1pbmUgd2hpY2ggY29sdW1ucyBhcmUgaW4gdGhpcyBicmVha3BvaW50IGJhc2VkXG5cdFx0Ly8gb24gdGhlIGNsYXNzZXMuIElmIG5vIGNsYXNzIGNvbnRyb2wgKGkuZS4gYGF1dG9gKSB0aGVuIGAtYCBpcyB1c2VkXG5cdFx0Ly8gdG8gaW5kaWNhdGUgdGhpcyB0byB0aGUgcmVzdCBvZiB0aGUgZnVuY3Rpb25cblx0XHR2YXIgZGlzcGxheSA9ICQubWFwKCBjb2x1bW5zLCBmdW5jdGlvbiAoIGNvbCwgaSApIHtcblx0XHRcdGlmICggZHQuY29sdW1uKGkpLnZpc2libGUoKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHJldHVybiAnbm90LXZpc2libGUnO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNvbC5hdXRvICYmIGNvbC5taW5XaWR0aCA9PT0gbnVsbCA/XG5cdFx0XHRcdGZhbHNlIDpcblx0XHRcdFx0Y29sLmF1dG8gPT09IHRydWUgP1xuXHRcdFx0XHRcdCctJyA6XG5cdFx0XHRcdFx0JC5pbkFycmF5KCBicmVha3BvaW50LCBjb2wuaW5jbHVkZUluICkgIT09IC0xO1xuXHRcdH0gKTtcblxuXHRcdC8vIEF1dG8gY29sdW1uIGNvbnRyb2wgLSBmaXJzdCBwYXNzOiBob3cgbXVjaCB3aWR0aCBpcyB0YWtlbiBieSB0aGVcblx0XHQvLyBvbmVzIHRoYXQgbXVzdCBiZSBpbmNsdWRlZCBmcm9tIHRoZSBub24tYXV0byBjb2x1bW5zXG5cdFx0dmFyIHJlcXVpcmVkV2lkdGggPSAwO1xuXHRcdGZvciAoIGk9MCwgaWVuPWRpc3BsYXkubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRpZiAoIGRpc3BsYXlbaV0gPT09IHRydWUgKSB7XG5cdFx0XHRcdHJlcXVpcmVkV2lkdGggKz0gY29sdW1uc1tpXS5taW5XaWR0aDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZWNvbmQgcGFzcywgdXNlIHVwIGFueSByZW1haW5pbmcgd2lkdGggZm9yIG90aGVyIGNvbHVtbnMuIEZvclxuXHRcdC8vIHNjcm9sbGluZyB0YWJsZXMgd2UgbmVlZCB0byBzdWJ0cmFjdCB0aGUgd2lkdGggb2YgdGhlIHNjcm9sbGJhci4gSXRcblx0XHQvLyBtYXkgbm90IGJlIHJlcXVpcmVzIHdoaWNoIG1ha2VzIHRoaXMgc3ViLW9wdGltYWwsIGJ1dCBpdCB3b3VsZFxuXHRcdC8vIHJlcXVpcmUgYW5vdGhlciBmdWxsIHJlZHJhdyB0byBtYWtlIGNvbXBsZXRlIHVzZSBvZiB0aG9zZSBleHRyYSBmZXdcblx0XHQvLyBwaXhlbHNcblx0XHR2YXIgc2Nyb2xsaW5nID0gZHQuc2V0dGluZ3MoKVswXS5vU2Nyb2xsO1xuXHRcdHZhciBiYXIgPSBzY3JvbGxpbmcuc1kgfHwgc2Nyb2xsaW5nLnNYID8gc2Nyb2xsaW5nLmlCYXJXaWR0aCA6IDA7XG5cdFx0dmFyIHdpZHRoQXZhaWxhYmxlID0gZHQudGFibGUoKS5jb250YWluZXIoKS5vZmZzZXRXaWR0aCAtIGJhcjtcblx0XHR2YXIgdXNlZFdpZHRoID0gd2lkdGhBdmFpbGFibGUgLSByZXF1aXJlZFdpZHRoO1xuXG5cdFx0Ly8gQ29udHJvbCBjb2x1bW4gbmVlZHMgdG8gYWx3YXlzIGJlIGluY2x1ZGVkLiBUaGlzIG1ha2VzIGl0IHN1Yi1cblx0XHQvLyBvcHRpbWFsIGluIHRlcm1zIG9mIHVzaW5nIHRoZSBhdmFpbGFibGUgd2l0aCwgYnV0IHRvIHN0b3AgbGF5b3V0XG5cdFx0Ly8gdGhyYXNoaW5nIG9yIG92ZXJmbG93LiBBbHNvIHdlIG5lZWQgdG8gYWNjb3VudCBmb3IgdGhlIGNvbnRyb2wgY29sdW1uXG5cdFx0Ly8gd2lkdGggZmlyc3Qgc28gd2Uga25vdyBob3cgbXVjaCB3aWR0aCBpcyBhdmFpbGFibGUgZm9yIHRoZSBvdGhlclxuXHRcdC8vIGNvbHVtbnMsIHNpbmNlIHRoZSBjb250cm9sIGNvbHVtbiBtaWdodCBub3QgYmUgdGhlIGZpcnN0IG9uZSBzaG93blxuXHRcdGZvciAoIGk9MCwgaWVuPWRpc3BsYXkubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRpZiAoIGNvbHVtbnNbaV0uY29udHJvbCApIHtcblx0XHRcdFx0dXNlZFdpZHRoIC09IGNvbHVtbnNbaV0ubWluV2lkdGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY29sdW1ucyB0byBiZSBzaG93biAoY291bnRpbmcgYnkgcHJpb3JpdHkgYW5kIHRoZW4gcmlnaHQgdG9cblx0XHQvLyBsZWZ0KSB1bnRpbCB3ZSBydW4gb3V0IG9mIHJvb21cblx0XHR2YXIgZW1wdHkgPSBmYWxzZTtcblx0XHRmb3IgKCBpPTAsIGllbj1vcmRlci5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdHZhciBjb2xJZHggPSBvcmRlcltpXS5jb2x1bW5JZHg7XG5cblx0XHRcdGlmICggZGlzcGxheVtjb2xJZHhdID09PSAnLScgJiYgISBjb2x1bW5zW2NvbElkeF0uY29udHJvbCAmJiBjb2x1bW5zW2NvbElkeF0ubWluV2lkdGggKSB7XG5cdFx0XHRcdC8vIE9uY2Ugd2UndmUgZm91bmQgYSBjb2x1bW4gdGhhdCB3b24ndCBmaXQgd2UgZG9uJ3QgbGV0IGFueVxuXHRcdFx0XHQvLyBvdGhlcnMgZGlzcGxheSBlaXRoZXIsIG9yIGNvbHVtbnMgbWlnaHQgZGlzYXBwZWFyIGluIHRoZVxuXHRcdFx0XHQvLyBtaWRkbGUgb2YgdGhlIHRhYmxlXG5cdFx0XHRcdGlmICggZW1wdHkgfHwgdXNlZFdpZHRoIC0gY29sdW1uc1tjb2xJZHhdLm1pbldpZHRoIDwgMCApIHtcblx0XHRcdFx0XHRlbXB0eSA9IHRydWU7XG5cdFx0XHRcdFx0ZGlzcGxheVtjb2xJZHhdID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0ZGlzcGxheVtjb2xJZHhdID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHVzZWRXaWR0aCAtPSBjb2x1bW5zW2NvbElkeF0ubWluV2lkdGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHRoZSAnY29udHJvbCcgY29sdW1uIHNob3VsZCBiZSBzaG93biAoaWYgdGhlcmUgaXMgb25lKS5cblx0XHQvLyBUaGlzIGlzIHRoZSBjYXNlIHdoZW4gdGhlcmUgaXMgYSBoaWRkZW4gY29sdW1uICh0aGF0IGlzIG5vdCB0aGVcblx0XHQvLyBjb250cm9sIGNvbHVtbikuIFRoZSB0d28gbG9vcHMgbG9vayBpbmVmZmljaWVudCBoZXJlLCBidXQgdGhleSBhcmVcblx0XHQvLyB0cml2aWFsIGFuZCB3aWxsIGZseSB0aHJvdWdoLiBXZSBuZWVkIHRvIGtub3cgdGhlIG91dGNvbWUgZnJvbSB0aGVcblx0XHQvLyBmaXJzdCAsIGJlZm9yZSB0aGUgYWN0aW9uIGluIHRoZSBzZWNvbmQgY2FuIGJlIHRha2VuXG5cdFx0dmFyIHNob3dDb250cm9sID0gZmFsc2U7XG5cblx0XHRmb3IgKCBpPTAsIGllbj1jb2x1bW5zLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0aWYgKCAhIGNvbHVtbnNbaV0uY29udHJvbCAmJiAhIGNvbHVtbnNbaV0ubmV2ZXIgJiYgZGlzcGxheVtpXSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHNob3dDb250cm9sID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICggaT0wLCBpZW49Y29sdW1ucy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGlmICggY29sdW1uc1tpXS5jb250cm9sICkge1xuXHRcdFx0XHRkaXNwbGF5W2ldID0gc2hvd0NvbnRyb2w7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlcGxhY2Ugbm90IHZpc2libGUgc3RyaW5nIHdpdGggZmFsc2UgZnJvbSB0aGUgY29udHJvbCBjb2x1bW4gZGV0ZWN0aW9uIGFib3ZlXG5cdFx0XHRpZiAoIGRpc3BsYXlbaV0gPT09ICdub3QtdmlzaWJsZScgKSB7XG5cdFx0XHRcdGRpc3BsYXlbaV0gPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaW5hbGx5IHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGNvbHVtbiB0aGF0XG5cdFx0Ly8gaXMgdmlzaWJsZVxuXHRcdGlmICggJC5pbkFycmF5KCB0cnVlLCBkaXNwbGF5ICkgPT09IC0xICkge1xuXHRcdFx0ZGlzcGxheVswXSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH0sXG5cblxuXHQvKipcblx0ICogQ3JlYXRlIHRoZSBpbnRlcm5hbCBgY29sdW1uc2AgYXJyYXkgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY29sdW1uc1xuXHQgKiBmb3IgdGhlIHRhYmxlLiBUaGlzIGluY2x1ZGVzIGRldGVybWluaW5nIHdoaWNoIGJyZWFrcG9pbnRzIHRoZSBjb2x1bW5cblx0ICogd2lsbCBhcHBlYXIgaW4sIGJhc2VkIHVwb24gY2xhc3MgbmFtZXMgaW4gdGhlIGNvbHVtbiwgd2hpY2ggbWFrZXMgdXAgdGhlXG5cdCAqIHZhc3QgbWFqb3JpdHkgb2YgdGhpcyBtZXRob2QuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfY2xhc3NMb2dpYzogZnVuY3Rpb24gKClcblx0e1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHR2YXIgY2FsYyA9IHt9O1xuXHRcdHZhciBicmVha3BvaW50cyA9IHRoaXMuYy5icmVha3BvaW50cztcblx0XHR2YXIgZHQgPSB0aGlzLnMuZHQ7XG5cdFx0dmFyIGNvbHVtbnMgPSBkdC5jb2x1bW5zKCkuZXEoMCkubWFwKCBmdW5jdGlvbiAoaSkge1xuXHRcdFx0dmFyIGNvbHVtbiA9IHRoaXMuY29sdW1uKGkpO1xuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IGNvbHVtbi5oZWFkZXIoKS5jbGFzc05hbWU7XG5cdFx0XHR2YXIgcHJpb3JpdHkgPSBkdC5zZXR0aW5ncygpWzBdLmFvQ29sdW1uc1tpXS5yZXNwb25zaXZlUHJpb3JpdHk7XG5cdFx0XHR2YXIgZGF0YVByaW9yaXR5ID0gY29sdW1uLmhlYWRlcigpLmdldEF0dHJpYnV0ZSgnZGF0YS1wcmlvcml0eScpO1xuXG5cdFx0XHRpZiAoIHByaW9yaXR5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHByaW9yaXR5ID0gZGF0YVByaW9yaXR5ID09PSB1bmRlZmluZWQgfHwgZGF0YVByaW9yaXR5ID09PSBudWxsP1xuXHRcdFx0XHRcdDEwMDAwIDpcblx0XHRcdFx0XHRkYXRhUHJpb3JpdHkgKiAxO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRjbGFzc05hbWU6IGNsYXNzTmFtZSxcblx0XHRcdFx0aW5jbHVkZUluOiBbXSxcblx0XHRcdFx0YXV0bzogICAgICBmYWxzZSxcblx0XHRcdFx0Y29udHJvbDogICBmYWxzZSxcblx0XHRcdFx0bmV2ZXI6ICAgICBjbGFzc05hbWUubWF0Y2goL1xcYm5ldmVyXFxiLykgPyB0cnVlIDogZmFsc2UsXG5cdFx0XHRcdHByaW9yaXR5OiAgcHJpb3JpdHlcblx0XHRcdH07XG5cdFx0fSApO1xuXG5cdFx0Ly8gU2ltcGx5IGFkZCBhIGJyZWFrcG9pbnQgdG8gYGluY2x1ZGVJbmAgYXJyYXksIGVuc3VyaW5nIHRoYXQgdGhlcmUgYXJlXG5cdFx0Ly8gbm8gZHVwbGljYXRlc1xuXHRcdHZhciBhZGQgPSBmdW5jdGlvbiAoIGNvbElkeCwgbmFtZSApIHtcblx0XHRcdHZhciBpbmNsdWRlSW4gPSBjb2x1bW5zWyBjb2xJZHggXS5pbmNsdWRlSW47XG5cblx0XHRcdGlmICggJC5pbkFycmF5KCBuYW1lLCBpbmNsdWRlSW4gKSA9PT0gLTEgKSB7XG5cdFx0XHRcdGluY2x1ZGVJbi5wdXNoKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHZhciBjb2x1bW4gPSBmdW5jdGlvbiAoIGNvbElkeCwgbmFtZSwgb3BlcmF0b3IsIG1hdGNoZWQgKSB7XG5cdFx0XHR2YXIgc2l6ZSwgaSwgaWVuO1xuXG5cdFx0XHRpZiAoICEgb3BlcmF0b3IgKSB7XG5cdFx0XHRcdGNvbHVtbnNbIGNvbElkeCBdLmluY2x1ZGVJbi5wdXNoKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggb3BlcmF0b3IgPT09ICdtYXgtJyApIHtcblx0XHRcdFx0Ly8gQWRkIHRoaXMgYnJlYWtwb2ludCBhbmQgYWxsIHNtYWxsZXJcblx0XHRcdFx0c2l6ZSA9IHRoYXQuX2ZpbmQoIG5hbWUgKS53aWR0aDtcblxuXHRcdFx0XHRmb3IgKCBpPTAsIGllbj1icmVha3BvaW50cy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGJyZWFrcG9pbnRzW2ldLndpZHRoIDw9IHNpemUgKSB7XG5cdFx0XHRcdFx0XHRhZGQoIGNvbElkeCwgYnJlYWtwb2ludHNbaV0ubmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIG9wZXJhdG9yID09PSAnbWluLScgKSB7XG5cdFx0XHRcdC8vIEFkZCB0aGlzIGJyZWFrcG9pbnQgYW5kIGFsbCBsYXJnZXJcblx0XHRcdFx0c2l6ZSA9IHRoYXQuX2ZpbmQoIG5hbWUgKS53aWR0aDtcblxuXHRcdFx0XHRmb3IgKCBpPTAsIGllbj1icmVha3BvaW50cy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGJyZWFrcG9pbnRzW2ldLndpZHRoID49IHNpemUgKSB7XG5cdFx0XHRcdFx0XHRhZGQoIGNvbElkeCwgYnJlYWtwb2ludHNbaV0ubmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIG9wZXJhdG9yID09PSAnbm90LScgKSB7XG5cdFx0XHRcdC8vIEFkZCBhbGwgYnV0IHRoaXMgYnJlYWtwb2ludFxuXHRcdFx0XHRmb3IgKCBpPTAsIGllbj1icmVha3BvaW50cy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGJyZWFrcG9pbnRzW2ldLm5hbWUuaW5kZXhPZiggbWF0Y2hlZCApID09PSAtMSApIHtcblx0XHRcdFx0XHRcdGFkZCggY29sSWR4LCBicmVha3BvaW50c1tpXS5uYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIExvb3Agb3ZlciBlYWNoIGNvbHVtbiBhbmQgZGV0ZXJtaW5lIGlmIGl0IGhhcyBhIHJlc3BvbnNpdmUgY29udHJvbFxuXHRcdC8vIGNsYXNzXG5cdFx0Y29sdW1ucy5lYWNoKCBmdW5jdGlvbiAoIGNvbCwgaSApIHtcblx0XHRcdHZhciBjbGFzc05hbWVzID0gY29sLmNsYXNzTmFtZS5zcGxpdCgnICcpO1xuXHRcdFx0dmFyIGhhc0NsYXNzID0gZmFsc2U7XG5cblx0XHRcdC8vIFNwbGl0IHRoZSBjbGFzcyBuYW1lIHVwIHNvIG11bHRpcGxlIHJ1bGVzIGNhbiBiZSBhcHBsaWVkIGlmIG5lZWRlZFxuXHRcdFx0Zm9yICggdmFyIGs9MCwga2VuPWNsYXNzTmFtZXMubGVuZ3RoIDsgazxrZW4gOyBrKysgKSB7XG5cdFx0XHRcdHZhciBjbGFzc05hbWUgPSBjbGFzc05hbWVzW2tdLnRyaW0oKTtcblxuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSA9PT0gJ2FsbCcgKSB7XG5cdFx0XHRcdFx0Ly8gSW5jbHVkZSBpbiBhbGxcblx0XHRcdFx0XHRoYXNDbGFzcyA9IHRydWU7XG5cdFx0XHRcdFx0Y29sLmluY2x1ZGVJbiA9ICQubWFwKCBicmVha3BvaW50cywgZnVuY3Rpb24gKGEpIHtcblx0XHRcdFx0XHRcdHJldHVybiBhLm5hbWU7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggY2xhc3NOYW1lID09PSAnbm9uZScgfHwgY29sLm5ldmVyICkge1xuXHRcdFx0XHRcdC8vIEluY2x1ZGUgaW4gbm9uZSAoZGVmYXVsdCkgYW5kIG5vIGF1dG9cblx0XHRcdFx0XHRoYXNDbGFzcyA9IHRydWU7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCBjbGFzc05hbWUgPT09ICdjb250cm9sJyB8fCBjbGFzc05hbWUgPT09ICdkdHItY29udHJvbCcgKSB7XG5cdFx0XHRcdFx0Ly8gU3BlY2lhbCBjb2x1bW4gdGhhdCBpcyBvbmx5IHZpc2libGUsIHdoZW4gb25lIG9mIHRoZSBvdGhlclxuXHRcdFx0XHRcdC8vIGNvbHVtbnMgaXMgaGlkZGVuLiBUaGlzIGlzIHVzZWQgZm9yIHRoZSBkZXRhaWxzIGNvbnRyb2xcblx0XHRcdFx0XHRoYXNDbGFzcyA9IHRydWU7XG5cdFx0XHRcdFx0Y29sLmNvbnRyb2wgPSB0cnVlO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdCQuZWFjaCggYnJlYWtwb2ludHMsIGZ1bmN0aW9uICggaiwgYnJlYWtwb2ludCApIHtcblx0XHRcdFx0XHQvLyBEb2VzIHRoaXMgY29sdW1uIGhhdmUgYSBjbGFzcyB0aGF0IG1hdGNoZXMgdGhpcyBicmVha3BvaW50P1xuXHRcdFx0XHRcdHZhciBicm9rZW5Qb2ludCA9IGJyZWFrcG9pbnQubmFtZS5zcGxpdCgnLScpO1xuXHRcdFx0XHRcdHZhciByZSA9IG5ldyBSZWdFeHAoICcobWluXFxcXC18bWF4XFxcXC18bm90XFxcXC0pPygnK2Jyb2tlblBvaW50WzBdKycpKFxcXFwtW19hLXpBLVowLTldKT8nICk7XG5cdFx0XHRcdFx0dmFyIG1hdGNoID0gY2xhc3NOYW1lLm1hdGNoKCByZSApO1xuXG5cdFx0XHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0XHRcdGhhc0NsYXNzID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaFsyXSA9PT0gYnJva2VuUG9pbnRbMF0gJiYgbWF0Y2hbM10gPT09ICctJyticm9rZW5Qb2ludFsxXSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gQ2xhc3MgbmFtZSBtYXRjaGVzIGJyZWFrcG9pbnQgbmFtZSBmdWxseVxuXHRcdFx0XHRcdFx0XHRjb2x1bW4oIGksIGJyZWFrcG9pbnQubmFtZSwgbWF0Y2hbMV0sIG1hdGNoWzJdK21hdGNoWzNdICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmICggbWF0Y2hbMl0gPT09IGJyb2tlblBvaW50WzBdICYmICEgbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0XHRcdC8vIENsYXNzIG5hbWUgbWF0Y2hlZCBwcmltYXJ5IGJyZWFrcG9pbnQgbmFtZSB3aXRoIG5vIHF1YWxpZmllclxuXHRcdFx0XHRcdFx0XHRjb2x1bW4oIGksIGJyZWFrcG9pbnQubmFtZSwgbWF0Y2hbMV0sIG1hdGNoWzJdICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoZXJlIHdhcyBubyBjb250cm9sIGNsYXNzLCB0aGVuIGF1dG9tYXRpYyBzaXppbmcgaXMgdXNlZFxuXHRcdFx0aWYgKCAhIGhhc0NsYXNzICkge1xuXHRcdFx0XHRjb2wuYXV0byA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0dGhpcy5zLmNvbHVtbnMgPSBjb2x1bW5zO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIGNlbGxzIHRvIHNob3cgdGhlIGNvcnJlY3QgY29udHJvbCBjbGFzcyAvIGJ1dHRvblxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2NvbnRyb2xDbGFzczogZnVuY3Rpb24gKClcblx0e1xuXHRcdGlmICggdGhpcy5jLmRldGFpbHMudHlwZSA9PT0gJ2lubGluZScgKSB7XG5cdFx0XHR2YXIgZHQgPSB0aGlzLnMuZHQ7XG5cdFx0XHR2YXIgY29sdW1uc1ZpcyA9IHRoaXMucy5jdXJyZW50O1xuXHRcdFx0dmFyIGZpcnN0VmlzaWJsZSA9ICQuaW5BcnJheSh0cnVlLCBjb2x1bW5zVmlzKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIGZyb20gYW55IGNlbGxzIHdoaWNoIHNob3VsZG4ndCBoYXZlIGl0XG5cdFx0XHRkdC5jZWxscyhcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0ZnVuY3Rpb24oaWR4KSB7XG5cdFx0XHRcdFx0cmV0dXJuIGlkeCAhPT0gZmlyc3RWaXNpYmxlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR7cGFnZTogJ2N1cnJlbnQnfVxuXHRcdFx0KVxuXHRcdFx0XHQubm9kZXMoKVxuXHRcdFx0XHQudG8kKClcblx0XHRcdFx0LmZpbHRlcignLmR0ci1jb250cm9sJylcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCdkdHItY29udHJvbCcpO1xuXG5cdFx0XHRkdC5jZWxscyhudWxsLCBmaXJzdFZpc2libGUsIHtwYWdlOiAnY3VycmVudCd9KVxuXHRcdFx0XHQubm9kZXMoKVxuXHRcdFx0XHQudG8kKClcblx0XHRcdFx0LmFkZENsYXNzKCdkdHItY29udHJvbCcpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogU2hvdyB0aGUgZGV0YWlscyBmb3IgdGhlIGNoaWxkIHJvd1xuXHQgKlxuXHQgKiBAcGFyYW0gIHtEYXRhVGFibGVzLkFwaX0gcm93ICAgIEFQSSBpbnN0YW5jZSBmb3IgdGhlIHJvd1xuXHQgKiBAcGFyYW0gIHtib29sZWFufSAgICAgICAgdXBkYXRlIFVwZGF0ZSBmbGFnXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZGV0YWlsc0Rpc3BsYXk6IGZ1bmN0aW9uICggcm93LCB1cGRhdGUgKVxuXHR7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdHZhciBkdCA9IHRoaXMucy5kdDtcblx0XHR2YXIgZGV0YWlscyA9IHRoaXMuYy5kZXRhaWxzO1xuXG5cdFx0aWYgKCBkZXRhaWxzICYmIGRldGFpbHMudHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR2YXIgcmVzID0gZGV0YWlscy5kaXNwbGF5KCByb3csIHVwZGF0ZSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gZGV0YWlscy5yZW5kZXJlcihcblx0XHRcdFx0XHRkdCwgcm93WzBdLCB0aGF0Ll9kZXRhaWxzT2JqKHJvd1swXSlcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblxuXHRcdFx0aWYgKCByZXMgPT09IHRydWUgfHwgcmVzID09PSBmYWxzZSApIHtcblx0XHRcdFx0JChkdC50YWJsZSgpLm5vZGUoKSkudHJpZ2dlckhhbmRsZXIoICdyZXNwb25zaXZlLWRpc3BsYXkuZHQnLCBbZHQsIHJvdywgcmVzLCB1cGRhdGVdICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0LyoqXG5cdCAqIEluaXRpYWxpc2F0aW9uIGZvciB0aGUgZGV0YWlscyBoYW5kbGVyXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZGV0YWlsc0luaXQ6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHR2YXIgdGhhdCAgICA9IHRoaXM7XG5cdFx0dmFyIGR0ICAgICAgPSB0aGlzLnMuZHQ7XG5cdFx0dmFyIGRldGFpbHMgPSB0aGlzLmMuZGV0YWlscztcblxuXHRcdC8vIFRoZSBpbmxpbmUgdHlwZSBhbHdheXMgdXNlcyB0aGUgZmlyc3QgY2hpbGQgYXMgdGhlIHRhcmdldFxuXHRcdGlmICggZGV0YWlscy50eXBlID09PSAnaW5saW5lJyApIHtcblx0XHRcdGRldGFpbHMudGFyZ2V0ID0gJ3RkLmR0ci1jb250cm9sLCB0aC5kdHItY29udHJvbCc7XG5cdFx0fVxuXG5cdFx0Ly8gS2V5Ym9hcmQgYWNjZXNzaWJpbGl0eVxuXHRcdGR0Lm9uKCAnZHJhdy5kdHInLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGF0Ll90YWJJbmRleGVzKCk7XG5cdFx0fSApO1xuXHRcdHRoYXQuX3RhYkluZGV4ZXMoKTsgLy8gSW5pdGlhbCBkcmF3IGhhcyBhbHJlYWR5IGhhcHBlbmVkXG5cblx0XHQkKCBkdC50YWJsZSgpLmJvZHkoKSApLm9uKCAna2V5dXAuZHRyJywgJ3RkLCB0aCcsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRpZiAoIGUua2V5Q29kZSA9PT0gMTMgJiYgJCh0aGlzKS5kYXRhKCdkdHIta2V5Ym9hcmQnKSApIHtcblx0XHRcdFx0JCh0aGlzKS5jbGljaygpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdC8vIHR5cGUudGFyZ2V0IGNhbiBiZSBhIHN0cmluZyBqUXVlcnkgc2VsZWN0b3Igb3IgYSBjb2x1bW4gaW5kZXhcblx0XHR2YXIgdGFyZ2V0ICAgPSBkZXRhaWxzLnRhcmdldDtcblx0XHR2YXIgc2VsZWN0b3IgPSB0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJyA/IHRhcmdldCA6ICd0ZCwgdGgnO1xuXG5cdFx0aWYgKCB0YXJnZXQgIT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgIT09IG51bGwgKSB7XG5cdFx0XHQvLyBDbGljayBoYW5kbGVyIHRvIHNob3cgLyBoaWRlIHRoZSBkZXRhaWxzIHJvd3Mgd2hlbiB0aGV5IGFyZSBhdmFpbGFibGVcblx0XHRcdCQoIGR0LnRhYmxlKCkuYm9keSgpIClcblx0XHRcdFx0Lm9uKCAnY2xpY2suZHRyIG1vdXNlZG93bi5kdHIgbW91c2V1cC5kdHInLCBzZWxlY3RvciwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHQvLyBJZiB0aGUgdGFibGUgaXMgbm90IGNvbGxhcHNlZCAoaS5lLiB0aGVyZSBpcyBubyBoaWRkZW4gY29sdW1ucylcblx0XHRcdFx0XHQvLyB0aGVuIHRha2Ugbm8gYWN0aW9uXG5cdFx0XHRcdFx0aWYgKCAhICQoZHQudGFibGUoKS5ub2RlKCkpLmhhc0NsYXNzKCdjb2xsYXBzZWQnICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgdGhhdCB0aGUgcm93IGlzIGFjdHVhbGx5IGEgRGF0YVRhYmxlJ3MgY29udHJvbGxlZCBub2RlXG5cdFx0XHRcdFx0aWYgKCAkLmluQXJyYXkoICQodGhpcykuY2xvc2VzdCgndHInKS5nZXQoMCksIGR0LnJvd3MoKS5ub2RlcygpLnRvQXJyYXkoKSApID09PSAtMSApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBGb3IgY29sdW1uIGluZGV4LCB3ZSBkZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIGFjdCBvciBub3QgaW4gdGhlXG5cdFx0XHRcdFx0Ly8gaGFuZGxlciAtIG90aGVyd2lzZSBpdCBpcyBhbHJlYWR5IG9rYXlcblx0XHRcdFx0XHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09ICdudW1iZXInICkge1xuXHRcdFx0XHRcdFx0dmFyIHRhcmdldElkeCA9IHRhcmdldCA8IDAgP1xuXHRcdFx0XHRcdFx0XHRkdC5jb2x1bW5zKCkuZXEoMCkubGVuZ3RoICsgdGFyZ2V0IDpcblx0XHRcdFx0XHRcdFx0dGFyZ2V0O1xuXG5cdFx0XHRcdFx0XHRpZiAoIGR0LmNlbGwoIHRoaXMgKS5pbmRleCgpLmNvbHVtbiAhPT0gdGFyZ2V0SWR4ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gJCgpLmNsb3Nlc3QoKSBpbmNsdWRlcyBpdHNlbGYgaW4gaXRzIGNoZWNrXG5cdFx0XHRcdFx0dmFyIHJvdyA9IGR0LnJvdyggJCh0aGlzKS5jbG9zZXN0KCd0cicpICk7XG5cblx0XHRcdFx0XHQvLyBDaGVjayBldmVudCB0eXBlIHRvIGRvIGFuIGFjdGlvblxuXHRcdFx0XHRcdGlmICggZS50eXBlID09PSAnY2xpY2snICkge1xuXHRcdFx0XHRcdFx0Ly8gVGhlIHJlbmRlcmVyIGlzIGdpdmVuIGFzIGEgZnVuY3Rpb24gc28gdGhlIGNhbGxlciBjYW4gZXhlY3V0ZSBpdFxuXHRcdFx0XHRcdFx0Ly8gb25seSB3aGVuIHRoZXkgbmVlZCAoaS5lLiBpZiBoaWRpbmcgdGhlcmUgaXMgbm8gcG9pbnQgaXMgcnVubmluZ1xuXHRcdFx0XHRcdFx0Ly8gdGhlIHJlbmRlcmVyKVxuXHRcdFx0XHRcdFx0dGhhdC5fZGV0YWlsc0Rpc3BsYXkoIHJvdywgZmFsc2UgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGUudHlwZSA9PT0gJ21vdXNlZG93bicgKSB7XG5cdFx0XHRcdFx0XHQvLyBGb3IgbW91c2UgdXNlcnMsIHByZXZlbnQgdGhlIGZvY3VzIHJpbmcgZnJvbSBzaG93aW5nXG5cdFx0XHRcdFx0XHQkKHRoaXMpLmNzcygnb3V0bGluZScsICdub25lJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKCBlLnR5cGUgPT09ICdtb3VzZXVwJyApIHtcblx0XHRcdFx0XHRcdC8vIEFuZCB0aGVuIHJlLWFsbG93IGF0IHRoZSBlbmQgb2YgdGhlIGNsaWNrXG5cdFx0XHRcdFx0XHQkKHRoaXMpLnRyaWdnZXIoJ2JsdXInKS5jc3MoJ291dGxpbmUnLCAnJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXHR9LFxuXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgZGV0YWlscyB0byBwYXNzIHRvIGEgcmVuZGVyZXIgZm9yIGEgcm93XG5cdCAqIEBwYXJhbSAge2ludH0gcm93SWR4IFJvdyBpbmRleFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2RldGFpbHNPYmo6IGZ1bmN0aW9uICggcm93SWR4IClcblx0e1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHR2YXIgZHQgPSB0aGlzLnMuZHQ7XG5cblx0XHRyZXR1cm4gJC5tYXAoIHRoaXMucy5jb2x1bW5zLCBmdW5jdGlvbiggY29sLCBpICkge1xuXHRcdFx0Ly8gTmV2ZXIgYW5kIGNvbnRyb2wgY29sdW1ucyBzaG91bGQgbm90IGJlIHBhc3NlZCB0byB0aGUgcmVuZGVyZXJcblx0XHRcdGlmICggY29sLm5ldmVyIHx8IGNvbC5jb250cm9sICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBkdENvbCA9IGR0LnNldHRpbmdzKClbMF0uYW9Db2x1bW5zWyBpIF07XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGNsYXNzTmFtZTogICBkdENvbC5zQ2xhc3MsXG5cdFx0XHRcdGNvbHVtbkluZGV4OiBpLFxuXHRcdFx0XHRkYXRhOiAgICAgICAgZHQuY2VsbCggcm93SWR4LCBpICkucmVuZGVyKCB0aGF0LmMub3J0aG9nb25hbCApLFxuXHRcdFx0XHRoaWRkZW46ICAgICAgZHQuY29sdW1uKCBpICkudmlzaWJsZSgpICYmICF0aGF0LnMuY3VycmVudFsgaSBdLFxuXHRcdFx0XHRyb3dJbmRleDogICAgcm93SWR4LFxuXHRcdFx0XHR0aXRsZTogICAgICAgZHRDb2wuc1RpdGxlICE9PSBudWxsID9cblx0XHRcdFx0XHRkdENvbC5zVGl0bGUgOlxuXHRcdFx0XHRcdCQoZHQuY29sdW1uKGkpLmhlYWRlcigpKS50ZXh0KClcblx0XHRcdH07XG5cdFx0fSApO1xuXHR9LFxuXG5cblx0LyoqXG5cdCAqIEZpbmQgYSBicmVha3BvaW50IG9iamVjdCBmcm9tIGEgbmFtZVxuXHQgKlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWUgQnJlYWtwb2ludCBuYW1lIHRvIGZpbmRcblx0ICogQHJldHVybiB7b2JqZWN0fSAgICAgIEJyZWFrcG9pbnQgZGVzY3JpcHRpb24gb2JqZWN0XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZmluZDogZnVuY3Rpb24gKCBuYW1lIClcblx0e1xuXHRcdHZhciBicmVha3BvaW50cyA9IHRoaXMuYy5icmVha3BvaW50cztcblxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1icmVha3BvaW50cy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGlmICggYnJlYWtwb2ludHNbaV0ubmFtZSA9PT0gbmFtZSApIHtcblx0XHRcdFx0cmV0dXJuIGJyZWFrcG9pbnRzW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdC8qKlxuXHQgKiBSZS1jcmVhdGUgdGhlIGNvbnRlbnRzIG9mIHRoZSBjaGlsZCByb3dzIGFzIHRoZSBkaXNwbGF5IGhhcyBjaGFuZ2VkIGluXG5cdCAqIHNvbWUgd2F5LlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3JlZHJhd0NoaWxkcmVuOiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdHZhciBkdCA9IHRoaXMucy5kdDtcblxuXHRcdGR0LnJvd3MoIHtwYWdlOiAnY3VycmVudCd9ICkuaXRlcmF0b3IoICdyb3cnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBpZHggKSB7XG5cdFx0XHR2YXIgcm93ID0gZHQucm93KCBpZHggKTtcblxuXHRcdFx0dGhhdC5fZGV0YWlsc0Rpc3BsYXkoIGR0LnJvdyggaWR4ICksIHRydWUgKTtcblx0XHR9ICk7XG5cdH0sXG5cblxuXHQvKipcblx0ICogQWx0ZXIgdGhlIHRhYmxlIGRpc3BsYXkgZm9yIGEgcmVzaXplZCB2aWV3cG9ydC4gVGhpcyBpbnZvbHZlcyBmaXJzdFxuXHQgKiBkZXRlcm1pbmluZyB3aGF0IGJyZWFrcG9pbnQgdGhlIHdpbmRvdyBjdXJyZW50bHkgaXMgaW4sIGdldHRpbmcgdGhlXG5cdCAqIGNvbHVtbiB2aXNpYmlsaXRpZXMgdG8gYXBwbHkgYW5kIHRoZW4gc2V0dGluZyB0aGVtLlxuXHQgKlxuXHQgKiBAcGFyYW0gIHtib29sZWFufSBmb3JjZVJlZHJhdyBGb3JjZSBhIHJlZHJhd1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3Jlc2l6ZTogZnVuY3Rpb24gKGZvcmNlUmVkcmF3KVxuXHR7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdHZhciBkdCA9IHRoaXMucy5kdDtcblx0XHR2YXIgd2lkdGggPSAkKHdpbmRvdykuaW5uZXJXaWR0aCgpO1xuXHRcdHZhciBicmVha3BvaW50cyA9IHRoaXMuYy5icmVha3BvaW50cztcblx0XHR2YXIgYnJlYWtwb2ludCA9IGJyZWFrcG9pbnRzWzBdLm5hbWU7XG5cdFx0dmFyIGNvbHVtbnMgPSB0aGlzLnMuY29sdW1ucztcblx0XHR2YXIgaSwgaWVuO1xuXHRcdHZhciBvbGRWaXMgPSB0aGlzLnMuY3VycmVudC5zbGljZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIHdoYXQgYnJlYWtwb2ludCB3ZSBhcmUgY3VycmVudGx5IGF0XG5cdFx0Zm9yICggaT1icmVha3BvaW50cy5sZW5ndGgtMSA7IGk+PTAgOyBpLS0gKSB7XG5cdFx0XHRpZiAoIHdpZHRoIDw9IGJyZWFrcG9pbnRzW2ldLndpZHRoICkge1xuXHRcdFx0XHRicmVha3BvaW50ID0gYnJlYWtwb2ludHNbaV0ubmFtZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8vIFNob3cgdGhlIGNvbHVtbnMgZm9yIHRoYXQgYnJlYWsgcG9pbnRcblx0XHR2YXIgY29sdW1uc1ZpcyA9IHRoaXMuX2NvbHVtbnNWaXNpYmxpdHkoIGJyZWFrcG9pbnQgKTtcblx0XHR0aGlzLnMuY3VycmVudCA9IGNvbHVtbnNWaXM7XG5cblx0XHQvLyBTZXQgdGhlIGNsYXNzIGJlZm9yZSB0aGUgY29sdW1uIHZpc2liaWxpdHkgaXMgY2hhbmdlZCBzbyBldmVudFxuXHRcdC8vIGxpc3RlbmVycyBrbm93IHdoYXQgdGhlIHN0YXRlIGlzLiBOZWVkIHRvIGRldGVybWluZSBpZiB0aGVyZSBhcmVcblx0XHQvLyBhbnkgY29sdW1ucyB0aGF0IGFyZSBub3QgdmlzaWJsZSBidXQgY2FuIGJlIHNob3duXG5cdFx0dmFyIGNvbGxhcHNlZENsYXNzID0gZmFsc2U7XG5cdFxuXHRcdGZvciAoIGk9MCwgaWVuPWNvbHVtbnMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRpZiAoIGNvbHVtbnNWaXNbaV0gPT09IGZhbHNlICYmICEgY29sdW1uc1tpXS5uZXZlciAmJiAhIGNvbHVtbnNbaV0uY29udHJvbCAmJiAhIGR0LmNvbHVtbihpKS52aXNpYmxlKCkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRjb2xsYXBzZWRDbGFzcyA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdCQoIGR0LnRhYmxlKCkubm9kZSgpICkudG9nZ2xlQ2xhc3MoICdjb2xsYXBzZWQnLCBjb2xsYXBzZWRDbGFzcyApO1xuXG5cdFx0dmFyIGNoYW5nZWQgPSBmYWxzZTtcblx0XHR2YXIgdmlzaWJsZSA9IDA7XG5cblx0XHRkdC5jb2x1bW5zKCkuZXEoMCkuZWFjaCggZnVuY3Rpb24gKCBjb2xJZHgsIGkgKSB7XG5cdFx0XHRpZiAoIGNvbHVtbnNWaXNbaV0gPT09IHRydWUgKSB7XG5cdFx0XHRcdHZpc2libGUrKztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBmb3JjZVJlZHJhdyB8fCBjb2x1bW5zVmlzW2ldICE9PSBvbGRWaXNbaV0gKSB7XG5cdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHR0aGF0Ll9zZXRDb2x1bW5WaXMoIGNvbElkeCwgY29sdW1uc1Zpc1tpXSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdGlmICggY2hhbmdlZCApIHtcblx0XHRcdHRoaXMuX3JlZHJhd0NoaWxkcmVuKCk7XG5cblx0XHRcdC8vIEluZm9ybSBsaXN0ZW5lcnMgb2YgdGhlIGNoYW5nZVxuXHRcdFx0JChkdC50YWJsZSgpLm5vZGUoKSkudHJpZ2dlciggJ3Jlc3BvbnNpdmUtcmVzaXplLmR0JywgW2R0LCB0aGlzLnMuY3VycmVudF0gKTtcblxuXHRcdFx0Ly8gSWYgbm8gcmVjb3JkcywgdXBkYXRlIHRoZSBcIk5vIHJlY29yZHNcIiBkaXNwbGF5IGVsZW1lbnRcblx0XHRcdGlmICggZHQucGFnZS5pbmZvKCkucmVjb3Jkc0Rpc3BsYXkgPT09IDAgKSB7XG5cdFx0XHRcdCQoJ3RkJywgZHQudGFibGUoKS5ib2R5KCkpLmVxKDApLmF0dHIoJ2NvbHNwYW4nLCB2aXNpYmxlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGF0Ll9jb250cm9sQ2xhc3MoKTtcblx0fSxcblxuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgdGhlIHdpZHRoIG9mIGVhY2ggY29sdW1uIGluIHRoZSB0YWJsZSBzbyB0aGUgYXV0byBjb2x1bW4gaGlkaW5nXG5cdCAqIGhhcyB0aGF0IGluZm9ybWF0aW9uIHRvIHdvcmsgd2l0aC4gVGhpcyBtZXRob2QgaXMgbmV2ZXIgZ29pbmcgdG8gYmUgMTAwJVxuXHQgKiBwZXJmZWN0IHNpbmNlIGNvbHVtbiB3aWR0aHMgY2FuIGNoYW5nZSBzbGlnaHRseSBwZXIgcGFnZSwgYnV0IHdpdGhvdXRcblx0ICogc2VyaW91c2x5IGNvbXByb21pc2luZyBwZXJmb3JtYW5jZSB0aGlzIGlzIHF1aXRlIGVmZmVjdGl2ZS5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9yZXNpemVBdXRvOiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0dmFyIGR0ID0gdGhpcy5zLmR0O1xuXHRcdHZhciBjb2x1bW5zID0gdGhpcy5zLmNvbHVtbnM7XG5cblx0XHQvLyBBcmUgd2UgYWxsb3dlZCB0byBkbyBhdXRvIHNpemluZz9cblx0XHRpZiAoICEgdGhpcy5jLmF1dG8gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQXJlIHRoZXJlIGFueSBjb2x1bW5zIHRoYXQgYWN0dWFsbHkgbmVlZCBhdXRvLXNpemluZywgb3IgZG8gdGhleSBhbGxcblx0XHQvLyBoYXZlIGNsYXNzZXMgZGVmaW5lZFxuXHRcdGlmICggJC5pbkFycmF5KCB0cnVlLCAkLm1hcCggY29sdW1ucywgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuYXV0bzsgfSApICkgPT09IC0xICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE5lZWQgdG8gcmVzdG9yZSBhbGwgY2hpbGRyZW4uIFRoZXkgd2lsbCBiZSByZWluc3RhdGVkIGJ5IGEgcmUtcmVuZGVyXG5cdFx0aWYgKCAhICQuaXNFbXB0eU9iamVjdCggX2NoaWxkTm9kZVN0b3JlICkgKSB7XG5cdFx0XHQkLmVhY2goIF9jaGlsZE5vZGVTdG9yZSwgZnVuY3Rpb24gKCBrZXkgKSB7XG5cdFx0XHRcdHZhciBpZHggPSBrZXkuc3BsaXQoJy0nKTtcblxuXHRcdFx0XHRfY2hpbGROb2Rlc1Jlc3RvcmUoIGR0LCBpZHhbMF0qMSwgaWR4WzFdKjEgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHQvLyBDbG9uZSB0aGUgdGFibGUgd2l0aCB0aGUgY3VycmVudCBkYXRhIGluIGl0XG5cdFx0dmFyIHRhYmxlV2lkdGggICA9IGR0LnRhYmxlKCkubm9kZSgpLm9mZnNldFdpZHRoO1xuXHRcdHZhciBjb2x1bW5XaWR0aHMgPSBkdC5jb2x1bW5zO1xuXHRcdHZhciBjbG9uZWRUYWJsZSAgPSBkdC50YWJsZSgpLm5vZGUoKS5jbG9uZU5vZGUoIGZhbHNlICk7XG5cdFx0dmFyIGNsb25lZEhlYWRlciA9ICQoIGR0LnRhYmxlKCkuaGVhZGVyKCkuY2xvbmVOb2RlKCBmYWxzZSApICkuYXBwZW5kVG8oIGNsb25lZFRhYmxlICk7XG5cdFx0dmFyIGNsb25lZEJvZHkgICA9ICQoIGR0LnRhYmxlKCkuYm9keSgpICkuY2xvbmUoIGZhbHNlLCBmYWxzZSApLmVtcHR5KCkuYXBwZW5kVG8oIGNsb25lZFRhYmxlICk7IC8vIHVzZSBqUXVlcnkgYmVjYXVzZSBvZiBJRThcblxuXHRcdGNsb25lZFRhYmxlLnN0eWxlLndpZHRoID0gJ2F1dG8nO1xuXG5cdFx0Ly8gSGVhZGVyXG5cdFx0dmFyIGhlYWRlckNlbGxzID0gZHQuY29sdW1ucygpXG5cdFx0XHQuaGVhZGVyKClcblx0XHRcdC5maWx0ZXIoIGZ1bmN0aW9uIChpZHgpIHtcblx0XHRcdFx0cmV0dXJuIGR0LmNvbHVtbihpZHgpLnZpc2libGUoKTtcblx0XHRcdH0gKVxuXHRcdFx0LnRvJCgpXG5cdFx0XHQuY2xvbmUoIGZhbHNlIClcblx0XHRcdC5jc3MoICdkaXNwbGF5JywgJ3RhYmxlLWNlbGwnIClcblx0XHRcdC5jc3MoICd3aWR0aCcsICdhdXRvJyApXG5cdFx0XHQuY3NzKCAnbWluLXdpZHRoJywgMCApO1xuXG5cdFx0Ly8gQm9keSByb3dzIC0gd2UgZG9uJ3QgbmVlZCB0byB0YWtlIGFjY291bnQgb2YgRGF0YVRhYmxlcycgY29sdW1uXG5cdFx0Ly8gdmlzaWJpbGl0eSBzaW5jZSB3ZSBpbXBsZW1lbnQgb3VyIG93biBoZXJlIChoZW5jZSB0aGUgYGRpc3BsYXlgIHNldClcblx0XHQkKGNsb25lZEJvZHkpXG5cdFx0XHQuYXBwZW5kKCAkKGR0LnJvd3MoIHsgcGFnZTogJ2N1cnJlbnQnIH0gKS5ub2RlcygpKS5jbG9uZSggZmFsc2UgKSApXG5cdFx0XHQuZmluZCggJ3RoLCB0ZCcgKS5jc3MoICdkaXNwbGF5JywgJycgKTtcblxuXHRcdC8vIEZvb3RlclxuXHRcdHZhciBmb290ZXIgPSBkdC50YWJsZSgpLmZvb3RlcigpO1xuXHRcdGlmICggZm9vdGVyICkge1xuXHRcdFx0dmFyIGNsb25lZEZvb3RlciA9ICQoIGZvb3Rlci5jbG9uZU5vZGUoIGZhbHNlICkgKS5hcHBlbmRUbyggY2xvbmVkVGFibGUgKTtcblx0XHRcdHZhciBmb290ZXJDZWxscyA9IGR0LmNvbHVtbnMoKVxuXHRcdFx0XHQuZm9vdGVyKClcblx0XHRcdFx0LmZpbHRlciggZnVuY3Rpb24gKGlkeCkge1xuXHRcdFx0XHRcdHJldHVybiBkdC5jb2x1bW4oaWR4KS52aXNpYmxlKCk7XG5cdFx0XHRcdH0gKVxuXHRcdFx0XHQudG8kKClcblx0XHRcdFx0LmNsb25lKCBmYWxzZSApXG5cdFx0XHRcdC5jc3MoICdkaXNwbGF5JywgJ3RhYmxlLWNlbGwnICk7XG5cblx0XHRcdCQoJzx0ci8+Jylcblx0XHRcdFx0LmFwcGVuZCggZm9vdGVyQ2VsbHMgKVxuXHRcdFx0XHQuYXBwZW5kVG8oIGNsb25lZEZvb3RlciApO1xuXHRcdH1cblxuXHRcdCQoJzx0ci8+Jylcblx0XHRcdC5hcHBlbmQoIGhlYWRlckNlbGxzIClcblx0XHRcdC5hcHBlbmRUbyggY2xvbmVkSGVhZGVyICk7XG5cblx0XHQvLyBJbiB0aGUgaW5saW5lIGNhc2UgZXh0cmEgcGFkZGluZyBpcyBhcHBsaWVkIHRvIHRoZSBmaXJzdCBjb2x1bW4gdG9cblx0XHQvLyBnaXZlIHNwYWNlIGZvciB0aGUgc2hvdyAvIGhpZGUgaWNvbi4gV2UgbmVlZCB0byB1c2UgdGhpcyBpbiB0aGVcblx0XHQvLyBjYWxjdWxhdGlvblxuXHRcdGlmICggdGhpcy5jLmRldGFpbHMudHlwZSA9PT0gJ2lubGluZScgKSB7XG5cdFx0XHQkKGNsb25lZFRhYmxlKS5hZGRDbGFzcyggJ2R0ci1pbmxpbmUgY29sbGFwc2VkJyApO1xuXHRcdH1cblx0XHRcblx0XHQvLyBJdCBpcyB1bnNhZmUgdG8gaW5zZXJ0IGVsZW1lbnRzIHdpdGggdGhlIHNhbWUgbmFtZSBpbnRvIHRoZSBET01cblx0XHQvLyBtdWx0aXBsZSB0aW1lcy4gRm9yIGV4YW1wbGUsIGNsb25pbmcgYW5kIGluc2VydGluZyBhIGNoZWNrZWQgcmFkaW9cblx0XHQvLyBjbGVhcnMgdGhlIGNoY2Vja2VkIHN0YXRlIG9mIHRoZSBvcmlnaW5hbCByYWRpby5cblx0XHQkKCBjbG9uZWRUYWJsZSApLmZpbmQoICdbbmFtZV0nICkucmVtb3ZlQXR0ciggJ25hbWUnICk7XG5cblx0XHQvLyBBIHBvc2l0aW9uIGFic29sdXRlIHRhYmxlIHdvdWxkIHRha2UgdGhlIHRhYmxlIG91dCBvZiB0aGUgZmxvdyBvZlxuXHRcdC8vIG91ciBjb250YWluZXIgZWxlbWVudCwgYnlwYXNzaW5nIHRoZSBoZWlnaHQgYW5kIHdpZHRoIChTY3JvbGxlcilcblx0XHQkKCBjbG9uZWRUYWJsZSApLmNzcyggJ3Bvc2l0aW9uJywgJ3JlbGF0aXZlJyApXG5cdFx0XG5cdFx0dmFyIGluc2VydGVkID0gJCgnPGRpdi8+Jylcblx0XHRcdC5jc3MoIHtcblx0XHRcdFx0d2lkdGg6IDEsXG5cdFx0XHRcdGhlaWdodDogMSxcblx0XHRcdFx0b3ZlcmZsb3c6ICdoaWRkZW4nLFxuXHRcdFx0XHRjbGVhcjogJ2JvdGgnXG5cdFx0XHR9IClcblx0XHRcdC5hcHBlbmQoIGNsb25lZFRhYmxlICk7XG5cblx0XHRpbnNlcnRlZC5pbnNlcnRCZWZvcmUoIGR0LnRhYmxlKCkubm9kZSgpICk7XG5cblx0XHQvLyBUaGUgY2xvbmVkIGhlYWRlciBub3cgY29udGFpbnMgdGhlIHNtYWxsZXN0IHRoYXQgZWFjaCBjb2x1bW4gY2FuIGJlXG5cdFx0aGVhZGVyQ2VsbHMuZWFjaCggZnVuY3Rpb24gKGkpIHtcblx0XHRcdHZhciBpZHggPSBkdC5jb2x1bW4uaW5kZXgoICdmcm9tVmlzaWJsZScsIGkgKTtcblx0XHRcdGNvbHVtbnNbIGlkeCBdLm1pbldpZHRoID0gIHRoaXMub2Zmc2V0V2lkdGggfHwgMDtcblx0XHR9ICk7XG5cblx0XHRpbnNlcnRlZC5yZW1vdmUoKTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSBzdGF0ZSBvZiB0aGUgY3VycmVudCBoaWRkZW4gY29sdW1ucyAtIGNvbnRyb2xsZWQgYnkgUmVzcG9uc2l2ZSBvbmx5XG5cdCAqL1xuXHRfcmVzcG9uc2l2ZU9ubHlIaWRkZW46IGZ1bmN0aW9uICgpXG5cdHtcblx0XHR2YXIgZHQgPSB0aGlzLnMuZHQ7XG5cblx0XHRyZXR1cm4gJC5tYXAoIHRoaXMucy5jdXJyZW50LCBmdW5jdGlvbiAodiwgaSkge1xuXHRcdFx0Ly8gSWYgdGhlIGNvbHVtbiBpcyBoaWRkZW4gYnkgRGF0YVRhYmxlcyB0aGVuIGl0IGNhbid0IGJlIGhpZGRlbiBieVxuXHRcdFx0Ly8gUmVzcG9uc2l2ZSFcblx0XHRcdGlmICggZHQuY29sdW1uKGkpLnZpc2libGUoKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHY7XG5cdFx0fSApO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgYSBjb2x1bW4ncyB2aXNpYmlsaXR5LlxuXHQgKlxuXHQgKiBXZSBkb24ndCB1c2UgRGF0YVRhYmxlcycgY29sdW1uIHZpc2liaWxpdHkgY29udHJvbHMgaW4gb3JkZXIgdG8gZW5zdXJlXG5cdCAqIHRoYXQgY29sdW1uIHZpc2liaWxpdHkgY2FuIFJlc3BvbnNpdmUgY2FuIG5vLWV4aXN0LiBTaW5jZSBvbmx5IElFOCsgaXNcblx0ICogc3VwcG9ydGVkIChhbmQgYWxsIGV2ZXJncmVlbiBicm93c2VycyBvZiBjb3Vyc2UpIHRoZSBjb250cm9sIG9mIHRoZVxuXHQgKiBkaXNwbGF5IGF0dHJpYnV0ZSB3b3JrcyB3ZWxsLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2ludGVnZXJ9IGNvbCAgICAgIENvbHVtbiBpbmRleFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3dIaWRlIFNob3cgb3IgaGlkZSAodHJ1ZSBvciBmYWxzZSlcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9zZXRDb2x1bW5WaXM6IGZ1bmN0aW9uICggY29sLCBzaG93SGlkZSApXG5cdHtcblx0XHR2YXIgZHQgPSB0aGlzLnMuZHQ7XG5cdFx0dmFyIGRpc3BsYXkgPSBzaG93SGlkZSA/ICcnIDogJ25vbmUnOyAvLyBlbXB0eSBzdHJpbmcgd2lsbCByZW1vdmUgdGhlIGF0dHJcblxuXHRcdCQoIGR0LmNvbHVtbiggY29sICkuaGVhZGVyKCkgKS5jc3MoICdkaXNwbGF5JywgZGlzcGxheSApO1xuXHRcdCQoIGR0LmNvbHVtbiggY29sICkuZm9vdGVyKCkgKS5jc3MoICdkaXNwbGF5JywgZGlzcGxheSApO1xuXHRcdGR0LmNvbHVtbiggY29sICkubm9kZXMoKS50byQoKS5jc3MoICdkaXNwbGF5JywgZGlzcGxheSApO1xuXG5cdFx0Ly8gSWYgdGhlIGFyZSBjaGlsZCBub2RlcyBzdG9yZWQsIHdlIG1pZ2h0IG5lZWQgdG8gcmVpbnNlcnQgdGhlbVxuXHRcdGlmICggISAkLmlzRW1wdHlPYmplY3QoIF9jaGlsZE5vZGVTdG9yZSApICkge1xuXHRcdFx0ZHQuY2VsbHMoIG51bGwsIGNvbCApLmluZGV4ZXMoKS5lYWNoKCBmdW5jdGlvbiAoaWR4KSB7XG5cdFx0XHRcdF9jaGlsZE5vZGVzUmVzdG9yZSggZHQsIGlkeC5yb3csIGlkeC5jb2x1bW4gKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBjZWxsIHRhYiBpbmRleGVzIGZvciBrZXlib2FyZCBhY2Nlc3NpYmlsaXR5LiBUaGlzIGlzIGNhbGxlZCBvblxuXHQgKiBldmVyeSB0YWJsZSBkcmF3IC0gdGhhdCBpcyBwb3RlbnRpYWxseSBpbmVmZmljaWVudCwgYnV0IGFsc28gdGhlIGxlYXN0XG5cdCAqIGNvbXBsZXggb3B0aW9uIGdpdmVuIHRoYXQgY29sdW1uIHZpc2liaWxpdHkgY2FuIGNoYW5nZSBvbiB0aGUgZmx5LiBJdHMgYVxuXHQgKiBzaGFtZSB1c2VyLWZvY3VzIHdhcyByZW1vdmVkIGZyb20gQ1NTIDMgVUksIGFzIGl0IHdvdWxkIGhhdmUgc29sdmVkIHRoaXNcblx0ICogaXNzdWUgd2l0aCBhIHNpbmdsZSBDU1Mgc3RhdGVtZW50LlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3RhYkluZGV4ZXM6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHR2YXIgZHQgPSB0aGlzLnMuZHQ7XG5cdFx0dmFyIGNlbGxzID0gZHQuY2VsbHMoIHsgcGFnZTogJ2N1cnJlbnQnIH0gKS5ub2RlcygpLnRvJCgpO1xuXHRcdHZhciBjdHggPSBkdC5zZXR0aW5ncygpWzBdO1xuXHRcdHZhciB0YXJnZXQgPSB0aGlzLmMuZGV0YWlscy50YXJnZXQ7XG5cblx0XHRjZWxscy5maWx0ZXIoICdbZGF0YS1kdHIta2V5Ym9hcmRdJyApLnJlbW92ZURhdGEoICdbZGF0YS1kdHIta2V5Ym9hcmRdJyApO1xuXG5cdFx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSAnbnVtYmVyJyApIHtcblx0XHRcdGR0LmNlbGxzKCBudWxsLCB0YXJnZXQsIHsgcGFnZTogJ2N1cnJlbnQnIH0gKS5ub2RlcygpLnRvJCgpXG5cdFx0XHRcdC5hdHRyKCAndGFiSW5kZXgnLCBjdHguaVRhYkluZGV4IClcblx0XHRcdFx0LmRhdGEoICdkdHIta2V5Ym9hcmQnLCAxICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gVGhpcyBpcyBhIGJpdCBvZiBhIGhhY2sgLSB3ZSBuZWVkIHRvIGxpbWl0IHRoZSBzZWxlY3RlZCBub2RlcyB0byBqdXN0XG5cdFx0XHQvLyB0aG9zZSBvZiB0aGlzIHRhYmxlXG5cdFx0XHRpZiAoIHRhcmdldCA9PT0gJ3RkOmZpcnN0LWNoaWxkLCB0aDpmaXJzdC1jaGlsZCcgKSB7XG5cdFx0XHRcdHRhcmdldCA9ICc+dGQ6Zmlyc3QtY2hpbGQsID50aDpmaXJzdC1jaGlsZCc7XG5cdFx0XHR9XG5cblx0XHRcdCQoIHRhcmdldCwgZHQucm93cyggeyBwYWdlOiAnY3VycmVudCcgfSApLm5vZGVzKCkgKVxuXHRcdFx0XHQuYXR0ciggJ3RhYkluZGV4JywgY3R4LmlUYWJJbmRleCApXG5cdFx0XHRcdC5kYXRhKCAnZHRyLWtleWJvYXJkJywgMSApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbi8qKlxuICogTGlzdCBvZiBkZWZhdWx0IGJyZWFrcG9pbnRzLiBFYWNoIGl0ZW0gaW4gdGhlIGFycmF5IGlzIGFuIG9iamVjdCB3aXRoIHR3b1xuICogcHJvcGVydGllczpcbiAqXG4gKiAqIGBuYW1lYCAtIHRoZSBicmVha3BvaW50IG5hbWUuXG4gKiAqIGB3aWR0aGAgLSB0aGUgYnJlYWtwb2ludCB3aWR0aFxuICpcbiAqIEBuYW1lIFJlc3BvbnNpdmUuYnJlYWtwb2ludHNcbiAqIEBzdGF0aWNcbiAqL1xuUmVzcG9uc2l2ZS5icmVha3BvaW50cyA9IFtcblx0eyBuYW1lOiAnZGVza3RvcCcsICB3aWR0aDogSW5maW5pdHkgfSxcblx0eyBuYW1lOiAndGFibGV0LWwnLCB3aWR0aDogMTAyNCB9LFxuXHR7IG5hbWU6ICd0YWJsZXQtcCcsIHdpZHRoOiA3NjggfSxcblx0eyBuYW1lOiAnbW9iaWxlLWwnLCB3aWR0aDogNDgwIH0sXG5cdHsgbmFtZTogJ21vYmlsZS1wJywgd2lkdGg6IDMyMCB9XG5dO1xuXG5cbi8qKlxuICogRGlzcGxheSBtZXRob2RzIC0gZnVuY3Rpb25zIHdoaWNoIGRlZmluZSBob3cgdGhlIGhpZGRlbiBkYXRhIHNob3VsZCBiZSBzaG93blxuICogaW4gdGhlIHRhYmxlLlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBuYW1lIFJlc3BvbnNpdmUuZGVmYXVsdHNcbiAqIEBzdGF0aWNcbiAqL1xuUmVzcG9uc2l2ZS5kaXNwbGF5ID0ge1xuXHRjaGlsZFJvdzogZnVuY3Rpb24gKCByb3csIHVwZGF0ZSwgcmVuZGVyICkge1xuXHRcdGlmICggdXBkYXRlICkge1xuXHRcdFx0aWYgKCAkKHJvdy5ub2RlKCkpLmhhc0NsYXNzKCdwYXJlbnQnKSApIHtcblx0XHRcdFx0cm93LmNoaWxkKCByZW5kZXIoKSwgJ2NoaWxkJyApLnNob3coKTtcblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAoICEgcm93LmNoaWxkLmlzU2hvd24oKSAgKSB7XG5cdFx0XHRcdHJvdy5jaGlsZCggcmVuZGVyKCksICdjaGlsZCcgKS5zaG93KCk7XG5cdFx0XHRcdCQoIHJvdy5ub2RlKCkgKS5hZGRDbGFzcyggJ3BhcmVudCcgKTtcblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRyb3cuY2hpbGQoIGZhbHNlICk7XG5cdFx0XHRcdCQoIHJvdy5ub2RlKCkgKS5yZW1vdmVDbGFzcyggJ3BhcmVudCcgKTtcblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGNoaWxkUm93SW1tZWRpYXRlOiBmdW5jdGlvbiAoIHJvdywgdXBkYXRlLCByZW5kZXIgKSB7XG5cdFx0aWYgKCAoISB1cGRhdGUgJiYgcm93LmNoaWxkLmlzU2hvd24oKSkgfHwgISByb3cucmVzcG9uc2l2ZS5oYXNIaWRkZW4oKSApIHtcblx0XHRcdC8vIFVzZXIgaW50ZXJhY3Rpb24gYW5kIHRoZSByb3cgaXMgc2hvdywgb3Igbm90aGluZyB0byBzaG93XG5cdFx0XHRyb3cuY2hpbGQoIGZhbHNlICk7XG5cdFx0XHQkKCByb3cubm9kZSgpICkucmVtb3ZlQ2xhc3MoICdwYXJlbnQnICk7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBEaXNwbGF5XG5cdFx0XHRyb3cuY2hpbGQoIHJlbmRlcigpLCAnY2hpbGQnICkuc2hvdygpO1xuXHRcdFx0JCggcm93Lm5vZGUoKSApLmFkZENsYXNzKCAncGFyZW50JyApO1xuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gVGhpcyBpcyBhIHdyYXBwZXIgc28gdGhlIG1vZGFsIG9wdGlvbnMgZm9yIEJvb3RzdHJhcCBhbmQgalF1ZXJ5IFVJIGNhblxuXHQvLyBoYXZlIG9wdGlvbnMgcGFzc2VkIGludG8gdGhlbS4gVGhpcyBzcGVjaWZpYyBvbmUgZG9lc24ndCBuZWVkIHRvIGJlIGFcblx0Ly8gZnVuY3Rpb24gYnV0IGl0IGlzIGZvciBjb25zaXN0ZW5jeSBpbiB0aGUgYG1vZGFsYCBuYW1lXG5cdG1vZGFsOiBmdW5jdGlvbiAoIG9wdGlvbnMgKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggcm93LCB1cGRhdGUsIHJlbmRlciApIHtcblx0XHRcdGlmICggISB1cGRhdGUgKSB7XG5cdFx0XHRcdC8vIFNob3cgYSBtb2RhbFxuXHRcdFx0XHR2YXIgY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0bW9kYWwucmVtb3ZlKCk7IC8vIHdpbGwgdGlkeSBldmVudHMgZm9yIHVzXG5cdFx0XHRcdFx0JChkb2N1bWVudCkub2ZmKCAna2V5cHJlc3MuZHRyJyApO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHZhciBtb2RhbCA9ICQoJzxkaXYgY2xhc3M9XCJkdHItbW9kYWxcIi8+Jylcblx0XHRcdFx0XHQuYXBwZW5kKCAkKCc8ZGl2IGNsYXNzPVwiZHRyLW1vZGFsLWRpc3BsYXlcIi8+Jylcblx0XHRcdFx0XHRcdC5hcHBlbmQoICQoJzxkaXYgY2xhc3M9XCJkdHItbW9kYWwtY29udGVudFwiLz4nKVxuXHRcdFx0XHRcdFx0XHQuYXBwZW5kKCByZW5kZXIoKSApXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQuYXBwZW5kKCAkKCc8ZGl2IGNsYXNzPVwiZHRyLW1vZGFsLWNsb3NlXCI+JnRpbWVzOzwvZGl2PicgKVxuXHRcdFx0XHRcdFx0XHQuY2xpY2soIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0XHRjbG9zZSgpO1xuXHRcdFx0XHRcdFx0XHR9IClcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0LmFwcGVuZCggJCgnPGRpdiBjbGFzcz1cImR0ci1tb2RhbC1iYWNrZ3JvdW5kXCIvPicpXG5cdFx0XHRcdFx0XHQuY2xpY2soIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0Y2xvc2UoKTtcblx0XHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdClcblx0XHRcdFx0XHQuYXBwZW5kVG8oICdib2R5JyApO1xuXG5cdFx0XHRcdCQoZG9jdW1lbnQpLm9uKCAna2V5dXAuZHRyJywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRpZiAoIGUua2V5Q29kZSA9PT0gMjcgKSB7XG5cdFx0XHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdFx0XHRcdFx0XHRjbG9zZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdCQoJ2Rpdi5kdHItbW9kYWwtY29udGVudCcpXG5cdFx0XHRcdFx0LmVtcHR5KClcblx0XHRcdFx0XHQuYXBwZW5kKCByZW5kZXIoKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG9wdGlvbnMgJiYgb3B0aW9ucy5oZWFkZXIgKSB7XG5cdFx0XHRcdCQoJ2Rpdi5kdHItbW9kYWwtY29udGVudCcpLnByZXBlbmQoXG5cdFx0XHRcdFx0JzxoMj4nK29wdGlvbnMuaGVhZGVyKCByb3cgKSsnPC9oMj4nXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufTtcblxuXG52YXIgX2NoaWxkTm9kZVN0b3JlID0ge307XG5cbmZ1bmN0aW9uIF9jaGlsZE5vZGVzKCBkdCwgcm93LCBjb2wgKSB7XG5cdHZhciBuYW1lID0gcm93KyctJytjb2w7XG5cblx0aWYgKCBfY2hpbGROb2RlU3RvcmVbIG5hbWUgXSApIHtcblx0XHRyZXR1cm4gX2NoaWxkTm9kZVN0b3JlWyBuYW1lIF07XG5cdH1cblxuXHQvLyBodHRwczovL2pzcGVyZi5jb20vY2hpbGRub2Rlcy1hcnJheS1zbGljZS12cy1sb29wXG5cdHZhciBub2RlcyA9IFtdO1xuXHR2YXIgY2hpbGRyZW4gPSBkdC5jZWxsKCByb3csIGNvbCApLm5vZGUoKS5jaGlsZE5vZGVzO1xuXHRmb3IgKCB2YXIgaT0wLCBpZW49Y2hpbGRyZW4ubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0bm9kZXMucHVzaCggY2hpbGRyZW5baV0gKTtcblx0fVxuXG5cdF9jaGlsZE5vZGVTdG9yZVsgbmFtZSBdID0gbm9kZXM7XG5cblx0cmV0dXJuIG5vZGVzO1xufVxuXG5mdW5jdGlvbiBfY2hpbGROb2Rlc1Jlc3RvcmUoIGR0LCByb3csIGNvbCApIHtcblx0dmFyIG5hbWUgPSByb3crJy0nK2NvbDtcblxuXHRpZiAoICEgX2NoaWxkTm9kZVN0b3JlWyBuYW1lIF0gKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIG5vZGUgPSBkdC5jZWxsKCByb3csIGNvbCApLm5vZGUoKTtcblx0dmFyIHN0b3JlID0gX2NoaWxkTm9kZVN0b3JlWyBuYW1lIF07XG5cdHZhciBwYXJlbnQgPSBzdG9yZVswXS5wYXJlbnROb2RlO1xuXHR2YXIgcGFyZW50Q2hpbGRyZW4gPSBwYXJlbnQuY2hpbGROb2Rlcztcblx0dmFyIGEgPSBbXTtcblxuXHRmb3IgKCB2YXIgaT0wLCBpZW49cGFyZW50Q2hpbGRyZW4ubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0YS5wdXNoKCBwYXJlbnRDaGlsZHJlbltpXSApO1xuXHR9XG5cblx0Zm9yICggdmFyIGo9MCwgamVuPWEubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0bm9kZS5hcHBlbmRDaGlsZCggYVtqXSApO1xuXHR9XG5cblx0X2NoaWxkTm9kZVN0b3JlWyBuYW1lIF0gPSB1bmRlZmluZWQ7XG59XG5cblxuLyoqXG4gKiBEaXNwbGF5IG1ldGhvZHMgLSBmdW5jdGlvbnMgd2hpY2ggZGVmaW5lIGhvdyB0aGUgaGlkZGVuIGRhdGEgc2hvdWxkIGJlIHNob3duXG4gKiBpbiB0aGUgdGFibGUuXG4gKlxuICogQG5hbWVzcGFjZVxuICogQG5hbWUgUmVzcG9uc2l2ZS5kZWZhdWx0c1xuICogQHN0YXRpY1xuICovXG5SZXNwb25zaXZlLnJlbmRlcmVyID0ge1xuXHRsaXN0SGlkZGVuTm9kZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBhcGksIHJvd0lkeCwgY29sdW1ucyApIHtcblx0XHRcdHZhciB1bCA9ICQoJzx1bCBkYXRhLWR0ci1pbmRleD1cIicrcm93SWR4KydcIiBjbGFzcz1cImR0ci1kZXRhaWxzXCIvPicpO1xuXHRcdFx0dmFyIGZvdW5kID0gZmFsc2U7XG5cblx0XHRcdHZhciBkYXRhID0gJC5lYWNoKCBjb2x1bW5zLCBmdW5jdGlvbiAoIGksIGNvbCApIHtcblx0XHRcdFx0aWYgKCBjb2wuaGlkZGVuICkge1xuXHRcdFx0XHRcdHZhciBrbGFzcyA9IGNvbC5jbGFzc05hbWUgP1xuXHRcdFx0XHRcdFx0J2NsYXNzPVwiJysgY29sLmNsYXNzTmFtZSArJ1wiJyA6XG5cdFx0XHRcdFx0XHQnJztcblx0XG5cdFx0XHRcdFx0JChcblx0XHRcdFx0XHRcdCc8bGkgJytrbGFzcysnIGRhdGEtZHRyLWluZGV4PVwiJytjb2wuY29sdW1uSW5kZXgrJ1wiIGRhdGEtZHQtcm93PVwiJytjb2wucm93SW5kZXgrJ1wiIGRhdGEtZHQtY29sdW1uPVwiJytjb2wuY29sdW1uSW5kZXgrJ1wiPicrXG5cdFx0XHRcdFx0XHRcdCc8c3BhbiBjbGFzcz1cImR0ci10aXRsZVwiPicrXG5cdFx0XHRcdFx0XHRcdFx0Y29sLnRpdGxlK1xuXHRcdFx0XHRcdFx0XHQnPC9zcGFuPiAnK1xuXHRcdFx0XHRcdFx0JzwvbGk+J1xuXHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdC5hcHBlbmQoICQoJzxzcGFuIGNsYXNzPVwiZHRyLWRhdGFcIi8+JykuYXBwZW5kKCBfY2hpbGROb2RlcyggYXBpLCBjb2wucm93SW5kZXgsIGNvbC5jb2x1bW5JbmRleCApICkgKS8vIGFwaS5jZWxsKCBjb2wucm93SW5kZXgsIGNvbC5jb2x1bW5JbmRleCApLm5vZGUoKS5jaGlsZE5vZGVzICkgKVxuXHRcdFx0XHRcdFx0LmFwcGVuZFRvKCB1bCApO1xuXG5cdFx0XHRcdFx0Zm91bmQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cblx0XHRcdHJldHVybiBmb3VuZCA/XG5cdFx0XHRcdHVsIDpcblx0XHRcdFx0ZmFsc2U7XG5cdFx0fTtcblx0fSxcblxuXHRsaXN0SGlkZGVuOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYXBpLCByb3dJZHgsIGNvbHVtbnMgKSB7XG5cdFx0XHR2YXIgZGF0YSA9ICQubWFwKCBjb2x1bW5zLCBmdW5jdGlvbiAoIGNvbCApIHtcblx0XHRcdFx0dmFyIGtsYXNzID0gY29sLmNsYXNzTmFtZSA/XG5cdFx0XHRcdFx0J2NsYXNzPVwiJysgY29sLmNsYXNzTmFtZSArJ1wiJyA6XG5cdFx0XHRcdFx0Jyc7XG5cblx0XHRcdFx0cmV0dXJuIGNvbC5oaWRkZW4gP1xuXHRcdFx0XHRcdCc8bGkgJytrbGFzcysnIGRhdGEtZHRyLWluZGV4PVwiJytjb2wuY29sdW1uSW5kZXgrJ1wiIGRhdGEtZHQtcm93PVwiJytjb2wucm93SW5kZXgrJ1wiIGRhdGEtZHQtY29sdW1uPVwiJytjb2wuY29sdW1uSW5kZXgrJ1wiPicrXG5cdFx0XHRcdFx0XHQnPHNwYW4gY2xhc3M9XCJkdHItdGl0bGVcIj4nK1xuXHRcdFx0XHRcdFx0XHRjb2wudGl0bGUrXG5cdFx0XHRcdFx0XHQnPC9zcGFuPiAnK1xuXHRcdFx0XHRcdFx0JzxzcGFuIGNsYXNzPVwiZHRyLWRhdGFcIj4nK1xuXHRcdFx0XHRcdFx0XHRjb2wuZGF0YStcblx0XHRcdFx0XHRcdCc8L3NwYW4+Jytcblx0XHRcdFx0XHQnPC9saT4nIDpcblx0XHRcdFx0XHQnJztcblx0XHRcdH0gKS5qb2luKCcnKTtcblxuXHRcdFx0cmV0dXJuIGRhdGEgP1xuXHRcdFx0XHQkKCc8dWwgZGF0YS1kdHItaW5kZXg9XCInK3Jvd0lkeCsnXCIgY2xhc3M9XCJkdHItZGV0YWlsc1wiLz4nKS5hcHBlbmQoIGRhdGEgKSA6XG5cdFx0XHRcdGZhbHNlO1xuXHRcdH1cblx0fSxcblxuXHR0YWJsZUFsbDogZnVuY3Rpb24gKCBvcHRpb25zICkge1xuXHRcdG9wdGlvbnMgPSAkLmV4dGVuZCgge1xuXHRcdFx0dGFibGVDbGFzczogJydcblx0XHR9LCBvcHRpb25zICk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBhcGksIHJvd0lkeCwgY29sdW1ucyApIHtcblx0XHRcdHZhciBkYXRhID0gJC5tYXAoIGNvbHVtbnMsIGZ1bmN0aW9uICggY29sICkge1xuXHRcdFx0XHR2YXIga2xhc3MgPSBjb2wuY2xhc3NOYW1lID9cblx0XHRcdFx0XHQnY2xhc3M9XCInKyBjb2wuY2xhc3NOYW1lICsnXCInIDpcblx0XHRcdFx0XHQnJztcblxuXHRcdFx0XHRyZXR1cm4gJzx0ciAnK2tsYXNzKycgZGF0YS1kdC1yb3c9XCInK2NvbC5yb3dJbmRleCsnXCIgZGF0YS1kdC1jb2x1bW49XCInK2NvbC5jb2x1bW5JbmRleCsnXCI+Jytcblx0XHRcdFx0XHRcdCc8dGQ+Jytjb2wudGl0bGUrJzonKyc8L3RkPiAnK1xuXHRcdFx0XHRcdFx0Jzx0ZD4nK2NvbC5kYXRhKyc8L3RkPicrXG5cdFx0XHRcdFx0JzwvdHI+Jztcblx0XHRcdH0gKS5qb2luKCcnKTtcblxuXHRcdFx0cmV0dXJuICQoJzx0YWJsZSBjbGFzcz1cIicrb3B0aW9ucy50YWJsZUNsYXNzKycgZHRyLWRldGFpbHNcIiB3aWR0aD1cIjEwMCVcIi8+JykuYXBwZW5kKCBkYXRhICk7XG5cdFx0fVxuXHR9XG59O1xuXG4vKipcbiAqIFJlc3BvbnNpdmUgZGVmYXVsdCBzZXR0aW5ncyBmb3IgaW5pdGlhbGlzYXRpb25cbiAqXG4gKiBAbmFtZXNwYWNlXG4gKiBAbmFtZSBSZXNwb25zaXZlLmRlZmF1bHRzXG4gKiBAc3RhdGljXG4gKi9cblJlc3BvbnNpdmUuZGVmYXVsdHMgPSB7XG5cdC8qKlxuXHQgKiBMaXN0IG9mIGJyZWFrcG9pbnRzIGZvciB0aGUgaW5zdGFuY2UuIE5vdGUgdGhhdCB0aGlzIG1lYW5zIHRoYXQgZWFjaFxuXHQgKiBpbnN0YW5jZSBjYW4gaGF2ZSBpdHMgb3duIGJyZWFrcG9pbnRzLiBBZGRpdGlvbmFsbHksIHRoZSBicmVha3BvaW50c1xuXHQgKiBjYW5ub3QgYmUgY2hhbmdlZCBvbmNlIGFuIGluc3RhbmNlIGhhcyBiZWVuIGNyZWFzZWQuXG5cdCAqXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICogQGRlZmF1bHQgVGFrZXMgdGhlIHZhbHVlIG9mIGBSZXNwb25zaXZlLmJyZWFrcG9pbnRzYFxuXHQgKi9cblx0YnJlYWtwb2ludHM6IFJlc3BvbnNpdmUuYnJlYWtwb2ludHMsXG5cblx0LyoqXG5cdCAqIEVuYWJsZSAvIGRpc2FibGUgYXV0byBoaWRpbmcgY2FsY3VsYXRpb25zLiBJdCBjYW4gaGVscCB0byBpbmNyZWFzZVxuXHQgKiBwZXJmb3JtYW5jZSBzbGlnaHRseSBpZiB5b3UgZGlzYWJsZSB0aGlzIG9wdGlvbiwgYnV0IGFsbCBjb2x1bW5zIHdvdWxkXG5cdCAqIG5lZWQgdG8gaGF2ZSBicmVha3BvaW50IGNsYXNzZXMgYXNzaWduZWQgdG8gdGhlbVxuXHQgKlxuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICogQGRlZmF1bHQgIGB0cnVlYFxuXHQgKi9cblx0YXV0bzogdHJ1ZSxcblxuXHQvKipcblx0ICogRGV0YWlscyBjb250cm9sLiBJZiBnaXZlbiBhcyBhIHN0cmluZyB2YWx1ZSwgdGhlIGB0eXBlYCBwcm9wZXJ0eSBvZiB0aGVcblx0ICogZGVmYXVsdCBvYmplY3QgaXMgc2V0IHRvIHRoYXQgdmFsdWUsIGFuZCB0aGUgZGVmYXVsdHMgdXNlZCBmb3IgdGhlIHJlc3Rcblx0ICogb2YgdGhlIG9iamVjdCAtIHRoaXMgaXMgZm9yIGVhc2Ugb2YgaW1wbGVtZW50YXRpb24uXG5cdCAqXG5cdCAqIFRoZSBvYmplY3QgY29uc2lzdHMgb2YgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuXHQgKlxuXHQgKiAqIGBkaXNwbGF5YCAtIEEgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIHNob3cgYW5kIGhpZGUgdGhlIGhpZGRlbiBkZXRhaWxzXG5cdCAqICogYHJlbmRlcmVyYCAtIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIGZvciBkaXNwbGF5IG9mIHRoZSBjaGlsZCByb3cgZGF0YS5cblx0ICogICBUaGUgZGVmYXVsdCBmdW5jdGlvbiB3aWxsIHNob3cgdGhlIGRhdGEgZnJvbSB0aGUgaGlkZGVuIGNvbHVtbnNcblx0ICogKiBgdGFyZ2V0YCAtIFVzZWQgYXMgdGhlIHNlbGVjdG9yIGZvciB3aGF0IG9iamVjdHMgdG8gYXR0YWNoIHRoZSBjaGlsZFxuXHQgKiAgIG9wZW4gLyBjbG9zZSB0b1xuXHQgKiAqIGB0eXBlYCAtIGBmYWxzZWAgdG8gZGlzYWJsZSB0aGUgZGV0YWlscyBkaXNwbGF5LCBgaW5saW5lYCBvciBgY29sdW1uYFxuXHQgKiAgIGZvciB0aGUgdHdvIGNvbnRyb2wgdHlwZXNcblx0ICpcblx0ICogQHR5cGUge09iamVjdHxzdHJpbmd9XG5cdCAqL1xuXHRkZXRhaWxzOiB7XG5cdFx0ZGlzcGxheTogUmVzcG9uc2l2ZS5kaXNwbGF5LmNoaWxkUm93LFxuXG5cdFx0cmVuZGVyZXI6IFJlc3BvbnNpdmUucmVuZGVyZXIubGlzdEhpZGRlbigpLFxuXG5cdFx0dGFyZ2V0OiAwLFxuXG5cdFx0dHlwZTogJ2lubGluZSdcblx0fSxcblxuXHQvKipcblx0ICogT3J0aG9nb25hbCBkYXRhIHJlcXVlc3Qgb3B0aW9uLiBUaGlzIGlzIHVzZWQgdG8gZGVmaW5lIHRoZSBkYXRhIHR5cGVcblx0ICogcmVxdWVzdGVkIHdoZW4gUmVzcG9uc2l2ZSBnZXRzIHRoZSBkYXRhIHRvIHNob3cgaW4gdGhlIGNoaWxkIHJvdy5cblx0ICpcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICovXG5cdG9ydGhvZ29uYWw6ICdkaXNwbGF5J1xufTtcblxuXG4vKlxuICogQVBJXG4gKi9cbnZhciBBcGkgPSAkLmZuLmRhdGFUYWJsZS5BcGk7XG5cbi8vIERvZXNuJ3QgZG8gYW55dGhpbmcgLSB3b3JrIGFyb3VuZCBmb3IgYSBidWcgaW4gRFQuLi4gTm90IGRvY3VtZW50ZWRcbkFwaS5yZWdpc3RlciggJ3Jlc3BvbnNpdmUoKScsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXM7XG59ICk7XG5cbkFwaS5yZWdpc3RlciggJ3Jlc3BvbnNpdmUuaW5kZXgoKScsIGZ1bmN0aW9uICggbGkgKSB7XG5cdGxpID0gJChsaSk7XG5cblx0cmV0dXJuIHtcblx0XHRjb2x1bW46IGxpLmRhdGEoJ2R0ci1pbmRleCcpLFxuXHRcdHJvdzogICAgbGkucGFyZW50KCkuZGF0YSgnZHRyLWluZGV4Jylcblx0fTtcbn0gKTtcblxuQXBpLnJlZ2lzdGVyKCAncmVzcG9uc2l2ZS5yZWJ1aWxkKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCApIHtcblx0XHRpZiAoIGN0eC5fcmVzcG9uc2l2ZSApIHtcblx0XHRcdGN0eC5fcmVzcG9uc2l2ZS5fY2xhc3NMb2dpYygpO1xuXHRcdH1cblx0fSApO1xufSApO1xuXG5BcGkucmVnaXN0ZXIoICdyZXNwb25zaXZlLnJlY2FsYygpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0aWYgKCBjdHguX3Jlc3BvbnNpdmUgKSB7XG5cdFx0XHRjdHguX3Jlc3BvbnNpdmUuX3Jlc2l6ZUF1dG8oKTtcblx0XHRcdGN0eC5fcmVzcG9uc2l2ZS5fcmVzaXplKCk7XG5cdFx0fVxuXHR9ICk7XG59ICk7XG5cbkFwaS5yZWdpc3RlciggJ3Jlc3BvbnNpdmUuaGFzSGlkZGVuKCknLCBmdW5jdGlvbiAoKSB7XG5cdHZhciBjdHggPSB0aGlzLmNvbnRleHRbMF07XG5cblx0cmV0dXJuIGN0eC5fcmVzcG9uc2l2ZSA/XG5cdFx0JC5pbkFycmF5KCBmYWxzZSwgY3R4Ll9yZXNwb25zaXZlLl9yZXNwb25zaXZlT25seUhpZGRlbigpICkgIT09IC0xIDpcblx0XHRmYWxzZTtcbn0gKTtcblxuQXBpLnJlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLnJlc3BvbnNpdmVIaWRkZW4oKScsICdjb2x1bW4oKS5yZXNwb25zaXZlSGlkZGVuKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uICkge1xuXHRcdHJldHVybiBzZXR0aW5ncy5fcmVzcG9uc2l2ZSA/XG5cdFx0XHRzZXR0aW5ncy5fcmVzcG9uc2l2ZS5fcmVzcG9uc2l2ZU9ubHlIaWRkZW4oKVsgY29sdW1uIF0gOlxuXHRcdFx0ZmFsc2U7XG5cdH0sIDEgKTtcbn0gKTtcblxuXG4vKipcbiAqIFZlcnNpb24gaW5mb3JtYXRpb25cbiAqXG4gKiBAbmFtZSBSZXNwb25zaXZlLnZlcnNpb25cbiAqIEBzdGF0aWNcbiAqL1xuUmVzcG9uc2l2ZS52ZXJzaW9uID0gJzIuMi45JztcblxuXG4kLmZuLmRhdGFUYWJsZS5SZXNwb25zaXZlID0gUmVzcG9uc2l2ZTtcbiQuZm4uRGF0YVRhYmxlLlJlc3BvbnNpdmUgPSBSZXNwb25zaXZlO1xuXG4vLyBBdHRhY2ggYSBsaXN0ZW5lciB0byB0aGUgZG9jdW1lbnQgd2hpY2ggbGlzdGVucyBmb3IgRGF0YVRhYmxlcyBpbml0aWFsaXNhdGlvblxuLy8gZXZlbnRzIHNvIHdlIGNhbiBhdXRvbWF0aWNhbGx5IGluaXRpYWxpc2VcbiQoZG9jdW1lbnQpLm9uKCAncHJlSW5pdC5kdC5kdHInLCBmdW5jdGlvbiAoZSwgc2V0dGluZ3MsIGpzb24pIHtcblx0aWYgKCBlLm5hbWVzcGFjZSAhPT0gJ2R0JyApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoICQoc2V0dGluZ3MublRhYmxlKS5oYXNDbGFzcyggJ3Jlc3BvbnNpdmUnICkgfHxcblx0XHQgJChzZXR0aW5ncy5uVGFibGUpLmhhc0NsYXNzKCAnZHQtcmVzcG9uc2l2ZScgKSB8fFxuXHRcdCBzZXR0aW5ncy5vSW5pdC5yZXNwb25zaXZlIHx8XG5cdFx0IERhdGFUYWJsZS5kZWZhdWx0cy5yZXNwb25zaXZlXG5cdCkge1xuXHRcdHZhciBpbml0ID0gc2V0dGluZ3Mub0luaXQucmVzcG9uc2l2ZTtcblxuXHRcdGlmICggaW5pdCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRuZXcgUmVzcG9uc2l2ZSggc2V0dGluZ3MsICQuaXNQbGFpbk9iamVjdCggaW5pdCApID8gaW5pdCA6IHt9ICApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbnJldHVybiBSZXNwb25zaXZlO1xufSkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/datatables.net-responsive/js/dataTables.responsive.js\n");

/***/ }),

/***/ "datatables.net":
/*!*********************************!*\
  !*** external "$.fn.dataTable" ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function() { module.exports = window[\"$.fn.dataTable\"]; }());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCIkLmZuLmRhdGFUYWJsZVwiPzgyMTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSwyQ0FBMkMsRUFBRSIsImZpbGUiOiJkYXRhdGFibGVzLm5ldC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpIHsgbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3dbXCIkLmZuLmRhdGFUYWJsZVwiXTsgfSgpKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///datatables.net\n");

/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function() { module.exports = window[\"jQuery\"]; }());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJqUXVlcnlcIj9jZDBjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUNBQW1DLEVBQUUiLCJmaWxlIjoianF1ZXJ5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCkgeyBtb2R1bGUuZXhwb3J0cyA9IHdpbmRvd1tcImpRdWVyeVwiXTsgfSgpKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///jquery\n");

/***/ })

/******/ })));